{"id": "c655", "nl_problem": "Find the largest value of $x$ for which\n\\[x^2 + y^2 = x + y\\]has a solution, if $x$ and $y$ are real.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem largest_x_with_y_solution :\n  IsMaxOn (fun x => x) {x : ℝ | ∃ y : ℝ, x^2 + y^2 = x + y} ((1 + Real.sqrt 2) / 2) :=", "formal_code": "import Mathlib\ntheorem largest_x_with_y_solution :\n  IsMaxOn (fun x => x) {x : ℝ | ∃ y : ℝ, x^2 + y^2 = x + y} ((1 + Real.sqrt 2) / 2) := by\n  have h_mem : (1 + Real.sqrt 2) / 2 ∈ {x : ℝ | ∃ y : ℝ, x^2 + y^2 = x + y} := by\n    use 1 / 2\n    have h₁ : ((1 + Real.sqrt 2) / 2 : ℝ) ^ 2 + (1 / 2 : ℝ) ^ 2 = (1 + Real.sqrt 2) / 2 + 1 / 2 := by\n      nlinarith [Real.sq_sqrt (show 0 ≤ 2 by norm_num), Real.sqrt_nonneg 2]\n    nlinarith [Real.sq_sqrt (show 0 ≤ 2 by norm_num), Real.sqrt_nonneg 2]\n  \n  have h_max : ∀ (x : ℝ), x ∈ {x : ℝ | ∃ y : ℝ, x^2 + y^2 = x + y} → x ≤ (1 + Real.sqrt 2) / 2 := by\n    intro x hx\n    rcases hx with ⟨y, hy⟩\n    have h₁ : x ^ 2 + y ^ 2 = x + y := hy\n    have h₂ : 4 * x ^ 2 - 4 * x - 1 ≤ 0 := by\n      nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (x - 1 / 2), sq_nonneg (y - x),\n        sq_nonneg (y + x - 1), sq_nonneg (y + x - 2 * x), sq_nonneg (y + x - 2 * y)]\n    have h₃ : x ≤ (1 + Real.sqrt 2) / 2 := by\n      nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 ≤ 2 by norm_num),\n        sq_nonneg (x - (1 + Real.sqrt 2) / 2), sq_nonneg (x - (1 - Real.sqrt 2) / 2)]\n    exact h₃\n  \n  have h_main : IsMaxOn (fun x => x) {x : ℝ | ∃ y : ℝ, x^2 + y^2 = x + y} ((1 + Real.sqrt 2) / 2) := by\n    refine' isMaxOn_iff.mpr _\n    intro x hx\n    have h₁ : x ≤ (1 + Real.sqrt 2) / 2 := h_max x hx\n    simpa using h₁\n  \n  exact h_main"}
{"id": "c776", "nl_problem": "If the sum of the squares of nonnegative real numbers $a,b,$ and $c$ is $13$, and $ab + bc + ca = 6$, then what is the sum of $a,b,$ and $c$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem verify_sum_from_squares_and_products (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) \n  (h1 : a^2 + b^2 + c^2 = 13) (h2 : a * b + b * c + c * a = 6) : \n  a + b + c = 5 :=", "formal_code": "import Mathlib\ntheorem verify_sum_from_squares_and_products (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) \n  (h1 : a^2 + b^2 + c^2 = 13) (h2 : a * b + b * c + c * a = 6) : \n  a + b + c = 5 := by\n  -- Step 1: Establish that (a + b + c)^2 = 25\n  have sum_sq : (a + b + c)^2 = 25 := by\n    have identity : (a + b + c)^2 = a^2 + b^2 + c^2 + 2 * (a * b + b * c + c * a) := by ring\n    rw [identity, h1, h2]\n    norm_num\n  \n  -- Step 2: Show that a + b + c ≥ 0\n  have sum_nonneg : 0 ≤ a + b + c := by linarith\n  \n  -- Step 3: From (a + b + c)^2 = 25 and a + b + c ≥ 0, conclude a + b + c = 5\n  have : a + b + c = Real.sqrt 25 := by\n    have h := Real.sqrt_sq sum_nonneg\n    rw [← h, sum_sq]\n  \n  rw [show Real.sqrt 25 = 5 by norm_num] at this\n  exact this"}
{"id": "c437", "nl_problem": "Name the greatest whole number less than $100$ that has an odd number of positive factors.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem max_perfect_square_below_100 : IsGreatest {n : ℕ | n < 100 ∧ ∃ m : ℕ, n = m^2} 81 :=", "formal_code": "import Mathlib\ntheorem max_perfect_square_below_100 : IsGreatest {n : ℕ | n < 100 ∧ ∃ m : ℕ, n = m^2} 81 := by\n  have h₁ : 81 ∈ {n : ℕ | n < 100 ∧ ∃ m : ℕ, n = m^2} := by\n    refine' ⟨by norm_num, _⟩\n    -- We need to find a natural number m such that 81 = m^2.\n    -- We know that 9^2 = 81, so we can choose m = 9.\n    refine' ⟨9, _⟩\n    -- Verify that 81 = 9^2.\n    <;> norm_num\n  \n  have h₂ : ∀ (n : ℕ), n ∈ {n : ℕ | n < 100 ∧ ∃ m : ℕ, n = m^2} → n ≤ 81 := by\n    intro n hn\n    have h₃ : n < 100 := hn.1\n    have h₄ : ∃ m : ℕ, n = m ^ 2 := hn.2\n    rcases h₄ with ⟨m, rfl⟩\n    -- We need to show that m^2 ≤ 81 given that m^2 < 100.\n    have h₅ : m ^ 2 < 100 := by simpa using h₃\n    have h₆ : m ≤ 9 := by\n      by_contra h\n      -- If m > 9, then m ≥ 10.\n      have h₇ : m ≥ 10 := by\n        by_contra h₇\n        omega\n      -- If m ≥ 10, then m^2 ≥ 100.\n      have h₈ : m ^ 2 ≥ 100 := by\n        have h₉ : m ≥ 10 := h₇\n        nlinarith\n      -- This contradicts m^2 < 100.\n      omega\n    -- Since m ≤ 9, we have m^2 ≤ 81.\n    have h₇ : m ^ 2 ≤ 81 := by\n      have h₈ : m ≤ 9 := h₆\n      interval_cases m <;> norm_num\n    exact h₇\n  \n  have h₃ : IsGreatest {n : ℕ | n < 100 ∧ ∃ m : ℕ, n = m^2} 81 := by\n    refine' ⟨h₁, _⟩\n    intro n hn\n    have h₄ : n ≤ 81 := h₂ n hn\n    exact h₄\n  \n  exact h₃"}
{"id": "c91", "nl_problem": "The prime factorization of 2160 is $2^4 \\times 3^3 \\times 5$. How many of its positive integer factors are perfect squares?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem count_square_factors_from_prime_decomposition : \n  let N : ℕ := 2160\n  N.factorization = Finsupp.single 2 4 + Finsupp.single 3 3 + Finsupp.single 5 1 →\n  (Finset.filter (fun d => (Nat.sqrt d) ^ 2 = d) (Nat.divisors N)).card = 6 :=", "formal_code": "import Mathlib\ntheorem count_square_factors_from_prime_decomposition : \n  let N : ℕ := 2160\n  N.factorization = Finsupp.single 2 4 + Finsupp.single 3 3 + Finsupp.single 5 1 →\n  (Finset.filter (fun d => (Nat.sqrt d) ^ 2 = d) (Nat.divisors N)).card = 6 := by\n  intro N hN\n  have h_main : (Finset.filter (fun d => (Nat.sqrt d) ^ 2 = d) (Nat.divisors N)).card = 6 := by\n    have h₁ : N = 2160 := rfl\n    rw [h₁] at hN ⊢\n    -- We need to show that the number of perfect squares dividing 2160 is 6.\n    -- First, we find the prime factorization of 2160.\n    -- 2160 = 2^4 * 3^3 * 5^1\n    -- The perfect squares dividing 2160 are those where the exponents of the primes in the factorization are even.\n    -- The exponents of 2 can be 0, 2, 4.\n    -- The exponents of 3 can be 0, 2.\n    -- The exponent of 5 can only be 0.\n    -- This gives us 3 * 2 * 1 = 6 combinations.\n    -- We list all the perfect squares:\n    -- 1, 4, 9, 16, 36, 144.\n    -- We need to verify that these are the only perfect squares dividing 2160.\n    -- We use the fact that the square root of a perfect square is an integer.\n    -- We also use the fact that the square root of a number is the largest integer whose square is less than or equal to the number.\n    -- We use the fact that the square root of a number is the largest integer whose square is less than or equal to the number.\n    -- We use the fact that the square root of a number is the largest integer whose square is less than or equal to the number.\n    -- We use the fact that the square root of a number is the largest integer whose square is less than or equal to the number.\n    rw [show (Finset.filter (fun d => (Nat.sqrt d) ^ 2 = d) (Nat.divisors 2160)) = {1, 4, 9, 16, 36, 144} by\n      -- We need to show that the set of perfect squares dividing 2160 is {1, 4, 9, 16, 36, 144}.\n      apply Finset.ext\n      intro d\n      simp only [Finset.mem_filter, Finset.mem_insert, Finset.mem_singleton, Nat.divisors]\n      constructor\n      · -- Prove the forward direction: if d is a perfect square dividing 2160, then d is in {1, 4, 9, 16, 36, 144}.\n        intro h\n        have h₂ : d ∣ 2160 := by aesop\n        have h₃ : (Nat.sqrt d) ^ 2 = d := by aesop\n        have h₄ : d ≤ 2160 := Nat.le_of_dvd (by norm_num) h₂\n        interval_cases d <;> norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc] at h₃ ⊢ <;>\n          (try omega) <;> (try aesop) <;> (try norm_num at h₂ ⊢) <;> (try omega) <;> (try aesop)\n      · -- Prove the reverse direction: if d is in {1, 4, 9, 16, 36, 144}, then d is a perfect square dividing 2160.\n        intro h\n        rcases h with (rfl | rfl | rfl | rfl | rfl | rfl)\n        · -- Case d = 1\n          norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc]\n          <;> decide\n        · -- Case d = 4\n          norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc]\n          <;> decide\n        · -- Case d = 9\n          norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc]\n          <;> decide\n        · -- Case d = 16\n          norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc]\n          <;> decide\n        · -- Case d = 36\n          norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc]\n          <;> decide\n        · -- Case d = 144\n          norm_num [Nat.sqrt_eq_zero, Nat.pow_succ, Nat.mul_assoc]\n          <;> decide\n    ]\n    -- Now we need to show that the cardinality of {1, 4, 9, 16, 36, 144} is 6.\n    rfl\n  exact h_main"}
{"id": "c352", "nl_problem": "The product of two positive three-digit palindromes is 436,995. What is their sum?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem palindrome_product_sum (p1 p2 : ℕ) \n  (h1 : 100 ≤ p1 ∧ p1 ≤ 999 ∧ (p1 / 100) = (p1 % 10))\n  (h2 : 100 ≤ p2 ∧ p2 ≤ 999 ∧ (p2 / 100) = (p2 % 10))\n  (h3 : p1 * p2 = 436995) : \n  p1 + p2 = 1332 :=", "formal_code": "import Mathlib\ntheorem palindrome_product_sum (p1 p2 : ℕ) \n  (h1 : 100 ≤ p1 ∧ p1 ≤ 999 ∧ (p1 / 100) = (p1 % 10))\n  (h2 : 100 ≤ p2 ∧ p2 ≤ 999 ∧ (p2 / 100) = (p2 % 10))\n  (h3 : p1 * p2 = 436995) : \n  p1 + p2 = 1332 := by\n  have h4 : p1 = 585 ∨ p1 = 747 := by\n    have h4₁ : p1 ≥ 100 := h1.1\n    have h4₂ : p1 ≤ 999 := h1.2.1\n    have h4₃ : p1 / 100 = p1 % 10 := h1.2.2\n    have h4₄ : p1 = 585 ∨ p1 = 747 := by\n      -- We know p1 is a 3-digit number with the first and last digits the same.\n      -- We can use the fact that p1 * p2 = 436995 to narrow down the possibilities.\n      have h4₅ : p1 = 585 ∨ p1 = 747 := by\n        -- We use the fact that p1 is a 3-digit number with the first and last digits the same.\n        -- We can use the fact that p1 * p2 = 436995 to narrow down the possibilities.\n        interval_cases p1 <;> norm_num at h4₃ ⊢ <;>\n          (try omega) <;>\n          (try\n            {\n              have h4₆ : p2 ≤ 999 := by omega\n              have h4₇ : p2 ≥ 100 := by omega\n              interval_cases p2 <;> norm_num at h3 ⊢ <;> omega\n            }) <;>\n          (try\n            {\n              omega\n            })\n      exact h4₅\n    exact h4₄\n  \n  have h5 : p2 = 585 ∨ p2 = 747 := by\n    have h5₁ : p2 ≥ 100 := h2.1\n    have h5₂ : p2 ≤ 999 := h2.2.1\n    have h5₃ : p2 / 100 = p2 % 10 := h2.2.2\n    have h5₄ : p2 = 585 ∨ p2 = 747 := by\n      -- We know p2 is a 3-digit number with the first and last digits the same.\n      -- We can use the fact that p1 * p2 = 436995 to narrow down the possibilities.\n      have h5₅ : p2 = 585 ∨ p2 = 747 := by\n        -- We use the fact that p2 is a 3-digit number with the first and last digits the same.\n        -- We can use the fact that p1 * p2 = 436995 to narrow down the possibilities.\n        interval_cases p2 <;> norm_num at h5₃ ⊢ <;>\n          (try omega) <;>\n          (try\n            {\n              have h5₆ : p1 ≤ 999 := by omega\n              have h5₇ : p1 ≥ 100 := by omega\n              interval_cases p1 <;> norm_num at h3 ⊢ <;> omega\n            }) <;>\n          (try\n            {\n              omega\n            })\n      exact h5₅\n    exact h5₄\n  \n  have h6 : p1 + p2 = 1332 := by\n    rcases h4 with (rfl | rfl) <;> rcases h5 with (rfl | rfl) <;> norm_num at h3 ⊢ <;>\n      (try omega) <;>\n      (try\n        {\n          ring_nf at h3 ⊢\n          <;> omega\n        })\n    <;>\n    (try\n      {\n        omega\n      })\n  \n  exact h6"}
