{"id": "c660", "nl_problem": "For $(x,y)$, positive integers, let  $10xy+14x+15y=166$.  Find $x+y$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem integer_equation_solution (x y : Int) (hx : x > 0) (hy : y > 0)\n    (h : 10 * x * y + 14 * x + 15 * y = 166) :\n  x + y = 6 :=", "formal_code": "import Mathlib\ntheorem integer_equation_solution (x y : Int) (hx : x > 0) (hy : y > 0)\n    (h : 10 * x * y + 14 * x + 15 * y = 166) :\n  x + y = 6 := by\n  have h₁ : x ≤ 11 := by\n    by_contra h₁\n    -- Assume x > 11 and derive a contradiction\n    have h₂ : x ≥ 12 := by linarith\n    have h₃ : 10 * x * y + 14 * x + 15 * y > 166 := by\n      have h₄ : y ≥ 1 := by linarith\n      have h₅ : 10 * x * y + 14 * x + 15 * y ≥ 10 * x * 1 + 14 * x + 15 * 1 := by\n        nlinarith\n      have h₆ : 10 * x * 1 + 14 * x + 15 * 1 > 166 := by\n        nlinarith\n      nlinarith\n    linarith\n  \n  have h₂ : x ≥ 1 := by\n    linarith\n  \n  have h₃ : y = (166 - 14 * x) / (10 * x + 15) := by\n    have h₄ : 10 * x * y + 14 * x + 15 * y = 166 := h\n    have h₅ : y * (10 * x + 15) = 166 - 14 * x := by\n      linarith\n    have h₆ : y = (166 - 14 * x) / (10 * x + 15) := by\n      have h₇ : (10 * x + 15 : ℤ) ∣ (166 - 14 * x : ℤ) := by\n        use y\n        linarith\n      have h₈ : y = (166 - 14 * x) / (10 * x + 15) := by\n        have h₉ : y * (10 * x + 15) = 166 - 14 * x := by linarith\n        have h₁₀ : y = (166 - 14 * x) / (10 * x + 15) := by\n          apply Eq.symm\n          apply Int.ediv_eq_of_eq_mul_right (by nlinarith)\n          linarith\n        exact h₁₀\n      exact h₈\n    exact h₆\n  \n  have h₄ : x = 4 := by\n    have h₅ : x ≥ 1 := h₂\n    have h₆ : x ≤ 11 := h₁\n    have h₇ : y = (166 - 14 * x) / (10 * x + 15) := h₃\n    have h₈ : y > 0 := hy\n    have h₉ : x > 0 := hx\n    -- We will check each possible value of x from 1 to 11 to find the valid solution\n    have h₁₀ : x = 4 := by\n      -- Use the fact that x is an integer and the bounds to check each case\n      have h₁₁ : x ≤ 11 := h₁\n      have h₁₂ : x ≥ 1 := h₂\n      interval_cases x <;> norm_num [h₇, Int.emod_eq_of_lt] at h₈ h₉ h ⊢ <;>\n        (try omega) <;> (try nlinarith) <;> (try\n          {\n            norm_num at h₈ h₉ h ⊢\n            <;>\n            (try omega) <;> (try nlinarith)\n          })\n    exact h₁₀\n  \n  have h₅ : y = 2 := by\n    have h₅₁ : y = (166 - 14 * x) / (10 * x + 15) := h₃\n    rw [h₄] at h₅₁\n    norm_num at h₅₁ ⊢\n    <;>\n    (try omega) <;>\n    (try nlinarith)\n    <;>\n    (try\n      {\n        norm_num at h₅₁ ⊢\n        <;>\n        omega\n      })\n  \n  have h₆ : x + y = 6 := by\n    rw [h₄, h₅]\n    <;> norm_num\n  \n  exact h₆"}
{"id": "c106", "nl_problem": "Find constants $A,$ $B,$ $C,$ and $D$ such that\n\\[\\frac{4x^3 - 20x^2 + 37x  -25}{(x-2)^3(x-1)} = \\frac{A}{x - 1} + \\frac{B}{(x -2)^3} + \\frac{C}{(x-2)^2}+\\frac{D}{x-2}.\\]Enter the order quadruple $(A,B,C,D).$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem partial_fraction_decomposition_uniqueness : \n  ∃! (t : ℝ × ℝ × ℝ × ℝ), \n    let (A, B, C, D) := t\n    (∀ x : ℝ, x ≠ 1 → x ≠ 2 → \n      (4 * x^3 - 20 * x^2 + 37 * x - 25) / ((x - 2)^3 * (x - 1)) = \n      A / (x - 1) + B / (x - 2)^3 + C / (x - 2)^2 + D / (x - 2)) ∧\n    t = (4, 1, 4, 0) :=", "formal_code": "import Mathlib\ntheorem partial_fraction_decomposition_uniqueness : \n  ∃! (t : ℝ × ℝ × ℝ × ℝ), \n    let (A, B, C, D) := t\n    (∀ x : ℝ, x ≠ 1 → x ≠ 2 → \n      (4 * x^3 - 20 * x^2 + 37 * x - 25) / ((x - 2)^3 * (x - 1)) = \n      A / (x - 1) + B / (x - 2)^3 + C / (x - 2)^2 + D / (x - 2)) ∧\n    t = (4, 1, 4, 0) := by\n  use (4, 1, 4, 0)\n  constructor\n  · constructor\n    · intro x hx1 hx2\n      have h1 : (x - 1) ≠ 0 := sub_ne_zero_of_ne hx1\n      have h2 : (x - 2) ≠ 0 := sub_ne_zero_of_ne hx2\n      have h3 : (x - 2)^3 ≠ 0 := pow_ne_zero 3 h2\n      field_simp [h1, h2, h3]\n      ring\n    · rfl\n  · intro t ⟨h_eq, h_tuple⟩\n    exact h_tuple"}
{"id": "c434", "nl_problem": "Let $p(x)$ be a polynomial of degree 5 such that\n\\[p(n) = \\frac{n}{n^2 - 1}\\]for $n = 2,$ 3, 4, $\\dots,$ 7.  Find $p(8).$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem polynomial_interpolation_rational (p : Polynomial ℚ) \n  (h_degree : p.natDegree = 5)\n  (h_eval : ∀ n : ℤ, n ∈ ({2, 3, 4, 5, 6, 7} : Set ℤ) → p.eval (n : ℚ) = (n : ℚ) / ((n : ℚ)^2 - 1)) :\n  p.eval (8 : ℚ) = 3 / 56 :=", "formal_code": "import Mathlib\ntheorem polynomial_interpolation_rational (p : Polynomial ℚ) \n  (h_degree : p.natDegree = 5)\n  (h_eval : ∀ n : ℤ, n ∈ ({2, 3, 4, 5, 6, 7} : Set ℤ) → p.eval (n : ℚ) = (n : ℚ) / ((n : ℚ)^2 - 1)) :\n  p.eval (8 : ℚ) = 3 / 56 := by\n  have h_main : p.eval (8 : ℚ) = 3 / 56 := by\n    have h1 := h_eval 2 (by norm_num)\n    have h2 := h_eval 3 (by norm_num)\n    have h3 := h_eval 4 (by norm_num)\n    have h4 := h_eval 5 (by norm_num)\n    have h5 := h_eval 6 (by norm_num)\n    have h6 := h_eval 7 (by norm_num)\n    norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at h1 h2 h3 h4 h5 h6 ⊢\n    <;>\n    (try norm_num at h1 h2 h3 h4 h5 h6 ⊢) <;>\n    (try ring_nf at h1 h2 h3 h4 h5 h6 ⊢) <;>\n    (try field_simp at h1 h2 h3 h4 h5 h6 ⊢) <;>\n    (try norm_cast at h1 h2 h3 h4 h5 h6 ⊢) <;>\n    (try simp_all [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero]) <;>\n    (try ring_nf at h1 h2 h3 h4 h5 h6 ⊢) <;>\n    (try norm_num at h1 h2 h3 h4 h5 h6 ⊢) <;>\n    (try linarith) <;>\n    (try nlinarith) <;>\n    (try\n      {\n        norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at *\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at *\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at *\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at *\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at *\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        norm_num [Polynomial.eval_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_zero] at *\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n  exact h_main"}
{"id": "c4250", "nl_problem": "Show that $m \\mathbb{Z}$ is a subgroup of $n \\mathbb{Z}$ if and only if $n$ divides $m$. (See Example 7.7.)", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem subgroup_inclusion_iff_divisibility (m n : ℤ) : \n  AddSubgroup.zmultiples m ≤ AddSubgroup.zmultiples n ↔ n ∣ m :=", "formal_code": "import Mathlib\ntheorem subgroup_inclusion_iff_divisibility (m n : ℤ) : \n  AddSubgroup.zmultiples m ≤ AddSubgroup.zmultiples n ↔ n ∣ m := by\n  constructor\n  · -- Forward direction: AddSubgroup.zmultiples m ≤ AddSubgroup.zmultiples n → n ∣ m\n    intro h\n    -- m is in AddSubgroup.zmultiples m\n    have hm : m ∈ AddSubgroup.zmultiples m := by\n      rw [Int.mem_zmultiples_iff]\n    -- By subgroup inclusion, m is in AddSubgroup.zmultiples n\n    have : m ∈ AddSubgroup.zmultiples n := h hm\n    -- Apply Int.mem_zmultiples_iff to conclude n ∣ m\n    rw [Int.mem_zmultiples_iff] at this\n    exact this\n  · -- Backward direction: n ∣ m → AddSubgroup.zmultiples m ≤ AddSubgroup.zmultiples n\n    intro hdiv\n    -- Show that every element of zmultiples m is in zmultiples n\n    intro x hx\n    -- x ∈ AddSubgroup.zmultiples m means m ∣ x\n    rw [Int.mem_zmultiples_iff] at hx\n    -- Since n ∣ m and m ∣ x, we have n ∣ x by transitivity\n    have : n ∣ x := dvd_trans hdiv hx\n    -- Therefore x ∈ AddSubgroup.zmultiples n\n    rw [Int.mem_zmultiples_iff]\n    exact this"}
{"id": "c4156", "nl_problem": "Show that $\\mathbb{Z}_{p}$ has no proper nontrivial subgroups if $p$ is a prime number.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem zmodp_no_nontrivial_subgroups (p : ℕ) [Fact (Nat.Prime p)] :\n  IsSimpleAddGroup (ZMod p) :=", "formal_code": "import Mathlib\ntheorem zmodp_no_nontrivial_subgroups (p : ℕ) [Fact (Nat.Prime p)] :\n  IsSimpleAddGroup (ZMod p) := by\n  haveI : Fintype (ZMod p) := ZMod.fintype p\n  have card_eq : Nat.card (ZMod p) = p := by\n    simp [Nat.card_eq_fintype_card, ZMod.card]\n  exact isSimpleAddGroup_of_prime_card card_eq"}
