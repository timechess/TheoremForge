{"id": "c1817", "nl_problem": "Let G be a finite group. Suppose there exists a positive natural number n such that for every element g in G, raising g to the power of n results in the identity element (g^n = 1). Prove that the exponent of G is less than or equal to n. (The exponent of a group is the least common multiple of the orders of all its elements).", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem group_exponent_bound (G : Type*) [Group G] [Finite G] \n  (n : ℕ) (hn : n > 0) (h : ∀ g : G, g^n = 1) : \n  Monoid.exponent G ≤ n :=", "formal_code": "import Mathlib\ntheorem group_exponent_bound (G : Type*) [Group G] [Finite G] \n  (n : ℕ) (hn : n > 0) (h : ∀ g : G, g^n = 1) : \n  Monoid.exponent G ≤ n := by\n  -- Use the equivalence: exponent G ∣ n ↔ ∀ g, g^n = 1\n  have exp_dvd_n : Monoid.exponent G ∣ n := by\n    rw [Monoid.exponent_dvd_iff_forall_pow_eq_one]\n    exact h\n  -- If exponent G divides n and n > 0, then exponent G ≤ n\n  exact Nat.le_of_dvd hn exp_dvd_n"}
{"id": "c1372", "nl_problem": "Prove the identity: $\\sum_{k=0}^{m} {n+k\\choose k} = {n+m+1\\choose m}$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem binomial_identity_hockey_stick (n m : ℕ) : \n  ∑ k in Finset.range (m + 1), (n + k).choose k = (n + m + 1).choose m :=", "formal_code": "import Mathlib\ntheorem binomial_identity_hockey_stick (n m : ℕ) : \n  ∑ k in Finset.range (m + 1), (n + k).choose k = (n + m + 1).choose m := by\n  induction m with\n  | zero =>\n    simp\n  | succ m ih =>\n    rw [Finset.sum_range_succ]\n    -- Goal: ∑ k ∈ Finset.range (m + 1), (n + k).choose k + (n + (m + 1)).choose (m + 1) = (n + (m + 1) + 1).choose (m + 1)\n    have h1 : ∑ k in Finset.range (m + 1), (n + k).choose k = (n + m + 1).choose m := ih\n    rw [h1]\n    -- Goal: (n + m + 1).choose m + (n + (m + 1)).choose (m + 1) = (n + (m + 1) + 1).choose (m + 1)\n    have h2 := Nat.choose_succ_succ' (n + m + 1) m\n    -- h2 : (n + m + 1 + 1).choose (m + 1) = (n + m + 1).choose m + (n + m + 1).choose (m + 1)\n    simp only [Nat.add_assoc] at h2 ⊢\n    exact h2.symm"}
{"id": "c1105", "nl_problem": "Prove the identity: $\\sum_{k=0}^{m} {n+k\\choose k} = {n+m+1\\choose m}$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem binomial_identity_sum (n m : ℕ) : \n  ∑ k in Finset.range (m + 1), Nat.choose (n + k) k = Nat.choose (n + m + 1) m :=", "formal_code": "import Mathlib\ntheorem binomial_identity_sum (n m : ℕ) : \n  ∑ k in Finset.range (m + 1), Nat.choose (n + k) k = Nat.choose (n + m + 1) m := by\n  have h₁ : ∑ k in Finset.range (m + 1), Nat.choose (n + k) k = ∑ k in Finset.range (m + 1), Nat.choose (n + k) n := by\n    apply Finset.sum_congr rfl\n    intro k hk\n    have h₂ : k < m + 1 := Finset.mem_range.mp hk\n    have h₃ : Nat.choose (n + k) k = Nat.choose (n + k) n := by\n      rw [Nat.choose_symm_of_eq_add]\n      <;> ring_nf at *\n      <;> omega\n    rw [h₃]\n  \n  have h₂ : ∑ k in Finset.range (m + 1), Nat.choose (n + k) n = ∑ k in Finset.range (m + 1), Nat.choose (k + n) n := by\n    apply Finset.sum_congr rfl\n    intro k hk\n    have h₃ : k < m + 1 := Finset.mem_range.mp hk\n    have h₄ : Nat.choose (n + k) n = Nat.choose (k + n) n := by\n      rw [add_comm]\n      <;> simp [add_comm, add_assoc, add_left_comm]\n    rw [h₄]\n  \n  have h₃ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = Nat.choose (m + n + 1) (n + 1) := by\n    have h₄ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = ∑ k in Finset.range (m + 1), Nat.choose (k + n) n := rfl\n    rw [h₄]\n    have h₅ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = Nat.choose (m + n + 1) (n + 1) := by\n      have h₆ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = ∑ k in Finset.range (m + 1), Nat.choose (k + n) n := rfl\n      rw [h₆]\n      -- Use the hockey-stick identity to evaluate the sum\n      have h₇ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = Nat.choose (m + n + 1) (n + 1) := by\n        -- Apply the hockey-stick identity\n        have h₈ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = ∑ k in Finset.range (m + 1), Nat.choose (k + n) n := rfl\n        rw [h₈]\n        -- Use the known identity to simplify the sum\n        have h₉ : ∑ k in Finset.range (m + 1), Nat.choose (k + n) n = Nat.choose (m + n + 1) (n + 1) := by\n          rw [eq_comm]\n          -- Use the hockey-stick identity from the library\n          rw [Nat.sum_range_add_choose]\n          <;> simp [add_assoc, add_comm, add_left_comm]\n          <;> ring_nf at *\n          <;> simp_all [Nat.choose_succ_succ]\n          <;> linarith\n        rw [h₉]\n      rw [h₇]\n    rw [h₅]\n  \n  have h₄ : Nat.choose (m + n + 1) (n + 1) = Nat.choose (n + m + 1) m := by\n    have h₅ : m + n + 1 = n + m + 1 := by\n      ring\n    rw [h₅]\n    have h₆ : Nat.choose (n + m + 1) (n + 1) = Nat.choose (n + m + 1) m := by\n      have h₇ : n + 1 + m = n + m + 1 := by ring\n      rw [← h₇]\n      rw [Nat.choose_symm_of_eq_add]\n      <;> ring_nf at *\n      <;> omega\n    rw [h₆]\n  \n  have h₅ : ∑ k in Finset.range (m + 1), Nat.choose (n + k) k = Nat.choose (n + m + 1) m := by\n    calc\n      ∑ k in Finset.range (m + 1), Nat.choose (n + k) k = ∑ k in Finset.range (m + 1), Nat.choose (n + k) n := h₁\n      _ = ∑ k in Finset.range (m + 1), Nat.choose (k + n) n := h₂\n      _ = Nat.choose (m + n + 1) (n + 1) := h₃\n      _ = Nat.choose (n + m + 1) m := h₄\n  \n  apply h₅"}
{"id": "c242", "nl_problem": "Find the $2 \\times 2$ matrix $\\mathbf{M}$ such that $\\mathbf{M} \\begin{pmatrix} 2 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} -15 \\\\ -6 \\end{pmatrix}$ and $\\mathbf{M} \\begin{pmatrix} 4 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 15 \\\\ 18 \\end{pmatrix}.$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem matrix_reconstruction_from_vectors : \n  ∃! M : Matrix (Fin 2) (Fin 2) ℝ, \n    M.mulVec ![2, 7] = ![-15, -6] ∧ \n    M.mulVec ![4, -1] = ![15, 18] :=", "formal_code": "import Mathlib\ntheorem matrix_reconstruction_from_vectors : \n  ∃! M : Matrix (Fin 2) (Fin 2) ℝ, \n    M.mulVec ![2, 7] = ![-15, -6] ∧ \n    M.mulVec ![4, -1] = ![15, 18] := by\n  use !![3, -3; 4, -2]\n  constructor\n  · constructor\n    · ext i\n      fin_cases i <;>\n      simp [Matrix.mulVec, Matrix.dotProduct, Fin.sum_univ_succ, Fin.val_zero, Fin.val_one]\n      <;> norm_num\n    · ext i\n      fin_cases i <;>\n      simp [Matrix.mulVec, Matrix.dotProduct, Fin.sum_univ_succ, Fin.val_zero, Fin.val_one]\n      <;> norm_num\n  · intro M' hM'\n    have h₁ : M'.mulVec ![2, 7] = ![-15, -6] := hM'.1\n    have h₂ : M'.mulVec ![4, -1] = ![15, 18] := hM'.2\n    \n    -- Extract equations from h₁\n    have eq1_0 : M' 0 0 * 2 + M' 0 1 * 7 = -15 := by\n      have := congr_arg (fun x => x 0) h₁\n      simp [Matrix.mulVec, Matrix.dotProduct, Fin.sum_univ_succ] at this\n      exact this\n    have eq1_1 : M' 1 0 * 2 + M' 1 1 * 7 = -6 := by\n      have := congr_arg (fun x => x 1) h₁\n      simp [Matrix.mulVec, Matrix.dotProduct, Fin.sum_univ_succ] at this\n      exact this\n    \n    -- Extract equations from h₂\n    have eq2_0 : M' 0 0 * 4 - M' 0 1 = 15 := by\n      have := congr_arg (fun x => x 0) h₂\n      simp [Matrix.mulVec, Matrix.dotProduct, Fin.sum_univ_succ] at this\n      exact this\n    have eq2_1 : M' 1 0 * 4 - M' 1 1 = 18 := by\n      have := congr_arg (fun x => x 1) h₂\n      simp [Matrix.mulVec, Matrix.dotProduct, Fin.sum_univ_succ] at this\n      exact this\n    \n    -- Solve for matrix entries\n    have h₃ : M' 0 0 = 3 := by nlinarith\n    have h₄ : M' 0 1 = -3 := by nlinarith\n    have h₅ : M' 1 0 = 4 := by nlinarith\n    have h₆ : M' 1 1 = -2 := by nlinarith\n    \n    -- Prove equality\n    ext i j\n    fin_cases i <;> fin_cases j <;> simp [h₃, h₄, h₅, h₆]"}
{"id": "c1809", "nl_problem": "Prove that the Bernstein polynomial of degree 'n' and index 'ν' evaluated at 1 is equal to 1 if 'ν' equals 'n', and 0 otherwise.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem bernstein_polynomial_evaluation_at_one (n ν : ℕ) (h : ν ≤ n) :\n  (bernsteinPolynomial ℝ n ν).eval 1 = if ν = n then 1 else 0 :=", "formal_code": "import Mathlib\ntheorem bernstein_polynomial_evaluation_at_one (n ν : ℕ) (h : ν ≤ n) :\n  (bernsteinPolynomial ℝ n ν).eval 1 = if ν = n then 1 else 0 := by\n  rw [bernsteinPolynomial.flip' ℝ n ν h, Polynomial.eval_comp]\n  simp only [Polynomial.eval_sub, Polynomial.eval_one, Polynomial.eval_X]\n  norm_num\n  rw [bernsteinPolynomial.eval_at_0]\n  by_cases h_eq : ν = n\n  · simp [h_eq]\n  · have : n - ν ≠ 0 := by omega\n    simp [this, h_eq]"}
{"id": "c603", "nl_problem": "Suppose $x-3$ and $y+3$ are multiples of $7$.\n\nWhat is the smallest positive integer, $n,$ for which $x^2+xy+y^2+n$ is a multiple of $7$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem min_n_modular_condition (x y : ℤ) \n  (hx : 7 ∣ (x - 3)) \n  (hy : 7 ∣ (y + 3)) : \n  (7 ∣ (x^2 + x*y + y^2 + 5)) ∧ \n  (∀ n : ℕ, 0 < n ∧ n < 5 → ¬(7 ∣ (x^2 + x*y + y^2 + n))) :=", "formal_code": "import Mathlib\ntheorem min_n_modular_condition (x y : ℤ) \n  (hx : 7 ∣ (x - 3)) \n  (hy : 7 ∣ (y + 3)) : \n  (7 ∣ (x^2 + x*y + y^2 + 5)) ∧ \n  (∀ n : ℕ, 0 < n ∧ n < 5 → ¬(7 ∣ (x^2 + x*y + y^2 + n))) := by\n  have hx_mod : x % 7 = 3 := by\n    have h₁ : x % 7 = 3 := by\n      have h₂ : (x - 3) % 7 = 0 := by\n        omega\n      have h₃ : x % 7 = 3 := by\n        have h₄ : (x - 3) % 7 = 0 := h₂\n        omega\n      exact h₃\n    exact h₁\n  \n  have hy_mod : y % 7 = 4 := by\n    have h₁ : y % 7 = 4 := by\n      have h₂ : (y + 3) % 7 = 0 := by\n        omega\n      have h₃ : y % 7 = 4 := by\n        have h₄ : (y + 3) % 7 = 0 := h₂\n        omega\n      exact h₃\n    exact h₁\n  \n  have h_main : (x^2 + x*y + y^2 + 5) % 7 = 0 := by\n    have h₁ : (x^2 + x*y + y^2 + 5) % 7 = 0 := by\n      have h₂ : x % 7 = 3 := hx_mod\n      have h₃ : y % 7 = 4 := hy_mod\n      have h₄ : (x^2 + x*y + y^2 + 5) % 7 = 0 := by\n        have h₅ : x % 7 = 3 := h₂\n        have h₆ : y % 7 = 4 := h₃\n        have h₇ : (x^2 + x*y + y^2 + 5) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 5 ) % 7 := by\n          have h₈ : (x^2 + x*y + y^2 + 5) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 5 ) % 7 := by\n            have h₉ : (x^2 + x*y + y^2 + 5) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 5 ) % 7 := by\n              norm_num [Int.add_emod, Int.mul_emod, pow_two]\n              <;>\n              (try omega) <;>\n              (try ring_nf at * <;> omega)\n            exact h₉\n          exact h₈\n        rw [h₇]\n        norm_num [h₅, h₆]\n        <;>\n        (try omega) <;>\n        (try ring_nf at * <;> omega)\n      exact h₄\n    exact h₁\n  \n  have h_div : 7 ∣ (x^2 + x*y + y^2 + 5) := by\n    have h₁ : (x^2 + x*y + y^2 + 5) % 7 = 0 := h_main\n    have h₂ : 7 ∣ (x^2 + x*y + y^2 + 5) := by\n      omega\n    exact h₂\n  \n  have h_sum_sq_mod : (x^2 + x*y + y^2) % 7 = 2 := by\n    have h₁ : (x^2 + x*y + y^2) % 7 = 2 := by\n      have h₂ : x % 7 = 3 := hx_mod\n      have h₃ : y % 7 = 4 := hy_mod\n      have h₄ : (x^2 + x*y + y^2) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 ) % 7 := by\n        have h₅ : (x^2 + x*y + y^2) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 ) % 7 := by\n          norm_num [Int.add_emod, Int.mul_emod, pow_two]\n          <;>\n          (try omega) <;>\n          (try ring_nf at * <;> omega)\n        exact h₅\n      rw [h₄]\n      norm_num [h₂, h₃]\n      <;>\n      (try omega) <;>\n      (try ring_nf at * <;> omega)\n    exact h₁\n  \n  have h_n1 : ¬(7 ∣ (x^2 + x*y + y^2 + (1 : ℤ))) := by\n    intro h\n    have h₁ : (x^2 + x*y + y^2 + (1 : ℤ)) % 7 = 0 := by\n      omega\n    have h₂ : (x^2 + x*y + y^2) % 7 = 2 := h_sum_sq_mod\n    have h₃ : (x^2 + x*y + y^2 + (1 : ℤ)) % 7 = 3 := by\n      have h₄ : x % 7 = 3 := hx_mod\n      have h₅ : y % 7 = 4 := hy_mod\n      have h₆ : (x^2 + x*y + y^2 + (1 : ℤ)) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 1 ) % 7 := by\n        norm_num [Int.add_emod, Int.mul_emod, pow_two]\n        <;>\n        (try omega) <;>\n        (try ring_nf at * <;> omega)\n      rw [h₆]\n      norm_num [h₄, h₅]\n      <;>\n      (try omega) <;>\n      (try ring_nf at * <;> omega)\n    omega\n  \n  have h_n2 : ¬(7 ∣ (x^2 + x*y + y^2 + (2 : ℤ))) := by\n    intro h\n    have h₁ : (x^2 + x*y + y^2 + (2 : ℤ)) % 7 = 0 := by\n      omega\n    have h₂ : (x^2 + x*y + y^2) % 7 = 2 := h_sum_sq_mod\n    have h₃ : (x^2 + x*y + y^2 + (2 : ℤ)) % 7 = 4 := by\n      have h₄ : x % 7 = 3 := hx_mod\n      have h₅ : y % 7 = 4 := hy_mod\n      have h₆ : (x^2 + x*y + y^2 + (2 : ℤ)) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 2 ) % 7 := by\n        norm_num [Int.add_emod, Int.mul_emod, pow_two]\n        <;>\n        (try omega) <;>\n        (try ring_nf at * <;> omega)\n      rw [h₆]\n      norm_num [h₄, h₅]\n      <;>\n      (try omega) <;>\n      (try ring_nf at * <;> omega)\n    omega\n  \n  have h_n3 : ¬(7 ∣ (x^2 + x*y + y^2 + (3 : ℤ))) := by\n    intro h\n    have h₁ : (x^2 + x*y + y^2 + (3 : ℤ)) % 7 = 0 := by\n      omega\n    have h₂ : (x^2 + x*y + y^2) % 7 = 2 := h_sum_sq_mod\n    have h₃ : (x^2 + x*y + y^2 + (3 : ℤ)) % 7 = 5 := by\n      have h₄ : x % 7 = 3 := hx_mod\n      have h₅ : y % 7 = 4 := hy_mod\n      have h₆ : (x^2 + x*y + y^2 + (3 : ℤ)) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 3 ) % 7 := by\n        norm_num [Int.add_emod, Int.mul_emod, pow_two]\n        <;>\n        (try omega) <;>\n        (try ring_nf at * <;> omega)\n      rw [h₆]\n      norm_num [h₄, h₅]\n      <;>\n      (try omega) <;>\n      (try ring_nf at * <;> omega)\n    omega\n  \n  have h_n4 : ¬(7 ∣ (x^2 + x*y + y^2 + (4 : ℤ))) := by\n    intro h\n    have h₁ : (x^2 + x*y + y^2 + (4 : ℤ)) % 7 = 0 := by\n      omega\n    have h₂ : (x^2 + x*y + y^2) % 7 = 2 := h_sum_sq_mod\n    have h₃ : (x^2 + x*y + y^2 + (4 : ℤ)) % 7 = 6 := by\n      have h₄ : x % 7 = 3 := hx_mod\n      have h₅ : y % 7 = 4 := hy_mod\n      have h₆ : (x^2 + x*y + y^2 + (4 : ℤ)) % 7 = ( (x % 7)^2 + (x % 7)*(y % 7) + (y % 7)^2 + 4 ) % 7 := by\n        norm_num [Int.add_emod, Int.mul_emod, pow_two]\n        <;>\n        (try omega) <;>\n        (try ring_nf at * <;> omega)\n      rw [h₆]\n      norm_num [h₄, h₅]\n      <;>\n      (try omega) <;>\n      (try ring_nf at * <;> omega)\n    omega\n  \n  have h_final : ∀ n : ℕ, 0 < n ∧ n < 5 → ¬(7 ∣ (x^2 + x*y + y^2 + n)) := by\n    intro n hn\n    have h₁ : n = 1 ∨ n = 2 ∨ n = 3 ∨ n = 4 := by\n      have h₂ : 0 < n := hn.1\n      have h₃ : n < 5 := hn.2\n      have h₄ : n ≤ 4 := by linarith\n      interval_cases n <;> simp_all (config := {decide := true})\n    rcases h₁ with (rfl | rfl | rfl | rfl)\n    · -- Case n = 1\n      intro h\n      have h₂ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (1 : ℕ)) := by simpa using h\n      have h₃ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (1 : ℤ)) := by\n        norm_cast at h₂ ⊢\n        <;> simpa [add_assoc] using h₂\n      exact h_n1 h₃\n    · -- Case n = 2\n      intro h\n      have h₂ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (2 : ℕ)) := by simpa using h\n      have h₃ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (2 : ℤ)) := by\n        norm_cast at h₂ ⊢\n        <;> simpa [add_assoc] using h₂\n      exact h_n2 h₃\n    · -- Case n = 3\n      intro h\n      have h₂ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (3 : ℕ)) := by simpa using h\n      have h₃ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (3 : ℤ)) := by\n        norm_cast at h₂ ⊢\n        <;> simpa [add_assoc] using h₂\n      exact h_n3 h₃\n    · -- Case n = 4\n      intro h\n      have h₂ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (4 : ℕ)) := by simpa using h\n      have h₃ : (7 : ℤ) ∣ (x^2 + x*y + y^2 + (4 : ℤ)) := by\n        norm_cast at h₂ ⊢\n        <;> simpa [add_assoc] using h₂\n      exact h_n4 h₃\n  \n  exact ⟨h_div, h_final⟩"}
{"id": "c1643", "nl_problem": "Prove that a number \\(x\\) is strictly less than the minimum element of a set \\(s\\) (denoted as \\(s.min'\\)) if and only if \\(x\\) is strictly less than every element in \\(s\\).", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem least_element_order_equivalence {α : Type*} [LinearOrder α] (x : α) (s : Set α) (m : α) \n  (hs_nonempty : s.Nonempty) (hm_least : IsLeast s m) : \n  x < m ↔ ∀ y ∈ s, x < y :=", "formal_code": "import Mathlib\ntheorem least_element_order_equivalence {α : Type*} [LinearOrder α] (x : α) (s : Set α) (m : α) \n  (hs_nonempty : s.Nonempty) (hm_least : IsLeast s m) : \n  x < m ↔ ∀ y ∈ s, x < y := by\n  constructor\n  · -- Forward direction: x < m → ∀ y ∈ s, x < y\n    intro hxm y hy\n    -- We have x < m and need to show x < y\n    -- From hm_least, we know m ≤ y (since y ∈ s)\n    have hmy : m ≤ y := hm_least.2 hy\n    -- Use transitivity: x < m and m ≤ y implies x < y\n    exact lt_of_lt_of_le hxm hmy\n  · -- Backward direction: (∀ y ∈ s, x < y) → x < m\n    intro h\n    -- We have ∀ y ∈ s, x < y\n    -- From hm_least, we know m ∈ s\n    have hm_mem : m ∈ s := hm_least.1\n    -- Apply the universal statement to m\n    exact h m hm_mem"}
{"id": "c1822", "nl_problem": "Let \\(R\\) be a ring and \\(M\\) be a module over \\(R\\). Consider two \\(R\\)-linear maps \\(f\\) and \\(g\\) from \\(R\\) to \\(M\\). Prove that \\(f\\) and \\(g\\) are equal if and only if \\(f(1) = g(1)\\), where \\(1\\) is the multiplicative identity in \\(R\\).", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem linear_map_equality_by_identity (R : Type*) [Ring R] (M : Type*) [AddCommGroup M] [Module R M] \n  (f g : R →ₗ[R] M) : f = g ↔ f 1 = g 1 :=", "formal_code": "import Mathlib\ntheorem linear_map_equality_by_identity (R : Type*) [Ring R] (M : Type*) [AddCommGroup M] [Module R M] \n  (f g : R →ₗ[R] M) : f = g ↔ f 1 = g 1 := by\n  have h_forward : f = g → f 1 = g 1 := by\n    intro h\n    rw [h]\n    <;> simp\n  \n  have h_backward : f 1 = g 1 → f = g := by\n    intro h\n    have h₁ : ∀ (r : R), f r = g r := by\n      intro r\n      have h₂ : f r = r • f 1 := by\n        calc\n          f r = f (r • (1 : R)) := by\n            simp [smul_eq_mul]\n            <;> ring_nf\n          _ = r • f 1 := by\n            apply LinearMap.map_smul\n      have h₃ : g r = r • g 1 := by\n        calc\n          g r = g (r • (1 : R)) := by\n            simp [smul_eq_mul]\n            <;> ring_nf\n          _ = r • g 1 := by\n            apply LinearMap.map_smul\n      calc\n        f r = r • f 1 := h₂\n        _ = r • g 1 := by rw [h]\n        _ = g r := by rw [h₃]\n    -- Now we need to show that f = g as linear maps.\n    -- Since they agree on all elements of R, they are equal.\n    have h₂ : f = g := by\n      apply LinearMap.ext\n      intro r\n      exact h₁ r\n    exact h₂\n  \n  have h_main : f = g ↔ f 1 = g 1 := by\n    constructor\n    · -- Prove the forward direction: if f = g, then f 1 = g 1\n      intro h\n      exact h_forward h\n    · -- Prove the backward direction: if f 1 = g 1, then f = g\n      intro h\n      exact h_backward h\n  \n  exact h_main"}
{"id": "c1713", "nl_problem": "Prove that the center of a group is a normal subgroup.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem center_is_normal_subgroup (G : Type*) [Group G] : \n  Subgroup.Normal (Subgroup.center G) :=", "formal_code": "import Mathlib\ntheorem center_is_normal_subgroup (G : Type*) [Group G] : \n  Subgroup.Normal (Subgroup.center G) := by\n  have h_main : ∀ (z : G), z ∈ Subgroup.center G → ∀ (g : G), g * z * g⁻¹ ∈ Subgroup.center G := by\n    intro z hz g\n    have h₁ : ∀ (g : G), g * z = z * g := by\n      intro g\n      have h₂ : z ∈ Subgroup.center G := hz\n      have h₃ : ∀ (g : G), g * z = z * g := by\n        intro g\n        have h₄ : z ∈ Subgroup.center G := hz\n        rw [Subgroup.mem_center_iff] at h₄\n        exact h₄ g\n      exact h₃ g\n    have h₂ : g * z * g⁻¹ = z := by\n      calc\n        g * z * g⁻¹ = z * g * g⁻¹ := by\n          rw [h₁ g]\n          <;> simp [mul_assoc]\n        _ = z * (g * g⁻¹) := by simp [mul_assoc]\n        _ = z * 1 := by simp\n        _ = z := by simp\n    rw [h₂]\n    exact hz\n  \n  have h_normal : Subgroup.Normal (Subgroup.center G) := by\n    refine' ⟨fun z hz g => _⟩\n    have h₁ : g * z * g⁻¹ ∈ Subgroup.center G := h_main z hz g\n    exact h₁\n  \n  exact h_normal"}
{"id": "c1093", "nl_problem": "Find all functions $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ such that $f(x+y) = f(x) + y$ for all $x, y \\in \\mathbb{R}$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem functional_equation_solution (f : ℝ → ℝ) : \n  (∀ x y : ℝ, f (x + y) = f x + y) ↔ (∃ c : ℝ, ∀ x : ℝ, f x = x + c) :=", "formal_code": "import Mathlib\ntheorem functional_equation_solution (f : ℝ → ℝ) : \n  (∀ x y : ℝ, f (x + y) = f x + y) ↔ (∃ c : ℝ, ∀ x : ℝ, f x = x + c) := by\n  constructor\n  · -- Forward direction: (∀ x y : ℝ, f (x + y) = f x + y) → (∃ c : ℝ, ∀ x : ℝ, f x = x + c)\n    intro h\n    use f 0\n    intro x\n    -- We have h(0)(x) : f(0 + x) = f(0) + x\n    have h0x := h 0 x\n    simp at h0x\n    rw [add_comm]\n    exact h0x\n  · -- Backward direction: (∃ c : ℝ, ∀ x : ℝ, f x = x + c) → (∀ x y : ℝ, f (x + y) = f x + y)\n    intro ⟨c, hc⟩\n    intro x y\n    rw [hc (x + y), hc x]\n    ring"}
