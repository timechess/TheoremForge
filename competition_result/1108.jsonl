{"id": "c321", "nl_problem": "Given that $a-b=5$ and $a^2+b^2=35$, find $a^3-b^3$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem prove_cubic_difference (a b : ℝ) (h1 : a - b = 5) (h2 : a^2 + b^2 = 35) : a^3 - b^3 = 200 :=", "formal_code": "import Mathlib\ntheorem prove_cubic_difference (a b : ℝ) (h1 : a - b = 5) (h2 : a^2 + b^2 = 35) : a^3 - b^3 = 200 := by\n\n  have h_sq : (a - b)^2 = a^2 + b^2 - 2*a*b := by ring\n  rw [h1] at h_sq\n  norm_num at h_sq\n\n  have h_ab : a * b = 5 := by linarith\n  \n\n  have h_factor : a^3 - b^3 = (a - b) * (a^2 + a*b + b^2) := by ring\n  \n\n  nlinarith [sq_nonneg (a - b), sq_nonneg (a + b)]"}
{"id": "c441", "nl_problem": "Find the product of the first $20$ terms of the sequence below. Express your answer as a common fraction.\n\n$\\frac23, \\frac34, \\frac45, \\frac56, \\dots$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem compute_product_sequence : \n  ∏ n in Finset.range 20, (n + 2 : ℚ) / (n + 3) = 1 / 11 :=", "formal_code": "import Mathlib\ntheorem compute_product_sequence : \n  ∏ n in Finset.range 20, (n + 2 : ℚ) / (n + 3) = 1 / 11 := by\n  norm_num [Finset.prod_range_succ, Finset.prod_div_distrib]"}
{"id": "c788", "nl_problem": "Let\n\\[f(x) = \\left\\{\n\\begin{array}{cl}\nx + 3 & \\text{if $x < 20$}, \\\\\n2x - 2 & \\text{if $x \\ge 20$}.\n\\end{array}\n\\right.\\]Find $f^{-1}(7) + f^{-1}(46).$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem inverse_function_sum : \n  let f : ℝ → ℝ := fun x => if x < 20 then x + 3 else 2 * x - 2\n  let preimage_7 := {x : ℝ | f x = 7}\n  let preimage_46 := {x : ℝ | f x = 46}\n  ∃ (a b : ℝ), a ∈ preimage_7 ∧ b ∈ preimage_46 ∧ a + b = 28 :=", "formal_code": "import Mathlib\ntheorem inverse_function_sum : \n  let f : ℝ → ℝ := fun x => if x < 20 then x + 3 else 2 * x - 2\n  let preimage_7 := {x : ℝ | f x = 7}\n  let preimage_46 := {x : ℝ | f x = 46}\n  ∃ (a b : ℝ), a ∈ preimage_7 ∧ b ∈ preimage_46 ∧ a + b = 28 := by\n  use 4, 24\n  constructor\n  ·\n    simp [Set.mem_setOf]\n    norm_num\n  constructor\n  ·\n    simp [Set.mem_setOf]\n    norm_num\n  ·\n    norm_num"}
{"id": "c368", "nl_problem": "A palindrome is a number that reads the same forward and backward. How many three-digit perfect squares are palindromes?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem count_palindromic_squares : \n  let is_three_digit := fun n => 100 ≤ n ∧ n ≤ 999\n  let is_perfect_square := fun n => ∃ k : ℕ, n = k^2\n  let is_palindrome := fun n => \n    let digits := Nat.digits 10 n\n    digits.head? = digits.getLast?\n  Set.ncard {n : ℕ | is_three_digit n ∧ is_perfect_square n ∧ is_palindrome n} = 3 :=", "formal_code": "import Mathlib\ntheorem count_palindromic_squares : \n  let is_three_digit := fun n => 100 ≤ n ∧ n ≤ 999\n  let is_perfect_square := fun n => ∃ k : ℕ, n = k^2\n  let is_palindrome := fun n => \n    let digits := Nat.digits 10 n\n    digits.head? = digits.getLast?\n  Set.ncard {n : ℕ | is_three_digit n ∧ is_perfect_square n ∧ is_palindrome n} = 3 := by\n  intro is_three_digit is_perfect_square is_palindrome\n  have h_main : {n : ℕ | is_three_digit n ∧ is_perfect_square n ∧ is_palindrome n} = {121, 484, 676} := by\n    apply Set.Subset.antisymm\n    ·\n      intro n hn\n      simp only [is_three_digit, is_perfect_square, is_palindrome, Set.mem_setOf_eq, Set.mem_insert_iff,\n        Set.mem_singleton_iff] at hn ⊢\n      have h₁ : 100 ≤ n := hn.1.1\n      have h₂ : n ≤ 999 := hn.1.2\n      have h₃ : ∃ k : ℕ, n = k ^ 2 := hn.2.1\n      have h₄ : (Nat.digits 10 n).head? = (Nat.digits 10 n).getLast? := hn.2.2\n\n      have h₅ : n = 121 ∨ n = 484 ∨ n = 676 := by\n\n        rcases h₃ with ⟨k, rfl⟩\n        have h₆ : 10 ≤ k := by\n          by_contra h\n          have h₇ : k ≤ 9 := by linarith\n          have h₈ : k ^ 2 ≤ 9 ^ 2 := by\n            exact Nat.pow_le_pow_of_le_left (by linarith) 2\n          have h₉ : k ^ 2 < 100 := by\n            nlinarith\n          linarith\n        have h₇ : k ≤ 31 := by\n          by_contra h\n          have h₈ : k ≥ 32 := by linarith\n          have h₉ : k ^ 2 ≥ 32 ^ 2 := by\n            exact Nat.pow_le_pow_of_le_left (by linarith) 2\n          have h₁₀ : k ^ 2 > 999 := by\n            nlinarith\n          linarith\n\n        interval_cases k <;> norm_num [Nat.digits_len, List.head?, List.getLast?] at h₄ ⊢ <;>\n          (try contradiction) <;> (try norm_num at h₄ ⊢) <;> (try aesop)\n\n      aesop\n    ·\n      intro n hn\n      simp only [is_three_digit, is_perfect_square, is_palindrome, Set.mem_setOf_eq, Set.mem_insert_iff,\n        Set.mem_singleton_iff] at hn ⊢\n      rcases hn with (rfl | rfl | rfl)\n      ·\n        constructor\n        ·\n          norm_num\n        ·\n          constructor\n          ·\n            use 11\n            <;> norm_num\n          ·\n            norm_num [Nat.digits_len, List.head?, List.getLast?]\n      ·\n        constructor\n        ·\n          norm_num\n        ·\n          constructor\n          ·\n            use 22\n            <;> norm_num\n          ·\n            norm_num [Nat.digits_len, List.head?, List.getLast?]\n      ·\n        constructor\n        ·\n          norm_num\n        ·\n          constructor\n          ·\n            use 26\n            <;> norm_num\n          ·\n            norm_num [Nat.digits_len, List.head?, List.getLast?]\n  \n  have h_card : Set.ncard {n : ℕ | is_three_digit n ∧ is_perfect_square n ∧ is_palindrome n} = 3 := by\n    rw [h_main]\n    norm_num\n    <;> decide\n  \n  exact h_card"}
{"id": "c1000", "nl_problem": "Given $a \\equiv 1$ or $2 \\pmod 3$, prove that $a^2 \\equiv 1 \\pmod 3$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem square_mod3_congruence : ∀ a : ℤ, (a ≡ 1 [ZMOD 3] ∨ a ≡ 2 [ZMOD 3]) → a^2 ≡ 1 [ZMOD 3] :=", "formal_code": "import Mathlib\ntheorem square_mod3_congruence : ∀ a : ℤ, (a ≡ 1 [ZMOD 3] ∨ a ≡ 2 [ZMOD 3]) → a^2 ≡ 1 [ZMOD 3] := by\n  intro a h\n  cases h with\n  | inl h1 =>\n\n    have mul_result : a * a ≡ 1 * 1 [ZMOD 3] := Int.ModEq.mul h1 h1\n    norm_num at mul_result\n    rw [pow_two]\n    exact mul_result\n  | inr h2 =>\n\n    have mul_result : a * a ≡ 2 * 2 [ZMOD 3] := Int.ModEq.mul h2 h2\n    norm_num at mul_result\n    rw [pow_two]\n    exact mul_result"}
{"id": "c1076", "nl_problem": "Show that $2^{65} + 1$ is divisible by 3.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem divisibility_by_three : (3 : ℤ) ∣ (2^65 + 1 : ℤ) :=", "formal_code": "import Mathlib\ntheorem divisibility_by_three : (3 : ℤ) ∣ (2^65 + 1 : ℤ) := by\n  have h₁ : (2 : ℤ) ≡ (-1 : ℤ) [ZMOD 3] := by\n    norm_num [Int.ModEq]\n    <;> decide\n  \n  have h₂ : (2 : ℤ)^65 ≡ (-1 : ℤ)^65 [ZMOD 3] := by\n\n    have h₂₁ : (2 : ℤ) ≡ (-1 : ℤ) [ZMOD 3] := h₁\n\n    have h₂₂ : (2 : ℤ)^65 ≡ (-1 : ℤ)^65 [ZMOD 3] := by\n\n      exact h₂₁.pow 65\n\n    exact h₂₂\n  \n  have h₃ : (2 : ℤ)^65 ≡ (-1 : ℤ) [ZMOD 3] := by\n    have h₃₁ : (2 : ℤ)^65 ≡ (-1 : ℤ)^65 [ZMOD 3] := h₂\n    have h₃₂ : (-1 : ℤ)^65 = (-1 : ℤ) := by\n      norm_num\n    have h₃₃ : (2 : ℤ)^65 ≡ (-1 : ℤ) [ZMOD 3] := by\n      calc\n        (2 : ℤ)^65 ≡ (-1 : ℤ)^65 [ZMOD 3] := h₃₁\n        _ = (-1 : ℤ) := by rw [h₃₂]\n        _ ≡ (-1 : ℤ) [ZMOD 3] := by rfl\n    exact h₃₃\n  \n  have h₄ : (2 : ℤ)^65 + 1 ≡ (0 : ℤ) [ZMOD 3] := by\n    have h₄₁ : (2 : ℤ)^65 ≡ (-1 : ℤ) [ZMOD 3] := h₃\n    have h₄₂ : (2 : ℤ)^65 + 1 ≡ (-1 : ℤ) + 1 [ZMOD 3] := by\n\n      exact Int.ModEq.add h₄₁ (Int.ModEq.refl 1)\n    have h₄₃ : (-1 : ℤ) + 1 = (0 : ℤ) := by norm_num\n    have h₄₄ : (2 : ℤ)^65 + 1 ≡ (0 : ℤ) [ZMOD 3] := by\n\n      calc\n        (2 : ℤ)^65 + 1 ≡ (-1 : ℤ) + 1 [ZMOD 3] := h₄₂\n        _ = (0 : ℤ) := by rw [h₄₃]\n        _ ≡ (0 : ℤ) [ZMOD 3] := by rfl\n    exact h₄₄\n  \n  have h₅ : (3 : ℤ) ∣ (2^65 + 1 : ℤ) := by\n    have h₅₁ : (2 : ℤ)^65 + 1 ≡ (0 : ℤ) [ZMOD 3] := h₄\n    have h₅₂ : (3 : ℤ) ∣ (2^65 + 1 : ℤ) := by\n\n      rw [Int.dvd_iff_emod_eq_zero]\n\n      have h₅₃ : ((2 : ℤ)^65 + 1) % 3 = 0 := by\n        rw [Int.ModEq] at h₅₁\n\n        omega\n\n      exact h₅₃\n    exact h₅₂\n  \n  exact h₅"}
{"id": "c1072", "nl_problem": "Prove the lemma: For positive $a, b, c, d$, if $\\frac{a}{b}>\\frac{c}{d}$, then $\\frac{a}{b}>\\frac{a+c}{b+d}>\\frac{c}{d}$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem fraction_inequality_strengthening (a b c d : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h : a / b > c / d) : a / b > (a + c) / (b + d) ∧ (a + c) / (b + d) > c / d :=", "formal_code": "import Mathlib\ntheorem fraction_inequality_strengthening (a b c d : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h : a / b > c / d) : a / b > (a + c) / (b + d) ∧ (a + c) / (b + d) > c / d := by\n  constructor\n  ·\n    have hbd : 0 < b + d := by linarith\n    rw [gt_iff_lt, div_lt_div_iff hbd hb]\n    have key : a * d > c * b := by\n      rw [gt_iff_lt, div_lt_div_iff hd hb] at h\n      exact h\n    nlinarith\n  ·\n    have hbd : 0 < b + d := by linarith\n    rw [gt_iff_lt, div_lt_div_iff hd hbd]\n    have key : a * d > c * b := by\n      rw [gt_iff_lt, div_lt_div_iff hd hb] at h\n      exact h\n    nlinarith"}
{"id": "c258", "nl_problem": "Suppose that $a$ and $b$ are integers such that   $$3b = 8 - 2a.$$How many of the first six positive integers must be divisors of $2b + 12$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem count_common_divisors_condition : \n  Set.ncard {d : ℤ | d ∈ ({1, 2, 3, 4, 5, 6} : Set ℤ) ∧ \n    ∀ (a b : ℤ), 3 * b = 8 - 2 * a → d ∣ (2 * b + 12)} = 3 :=", "formal_code": "import Mathlib\ntheorem count_common_divisors_condition : \n  Set.ncard {d : ℤ | d ∈ ({1, 2, 3, 4, 5, 6} : Set ℤ) ∧ \n    ∀ (a b : ℤ), 3 * b = 8 - 2 * a → d ∣ (2 * b + 12)} = 3 := by\n  have h_main : {d : ℤ | d ∈ ({1, 2, 3, 4, 5, 6} : Set ℤ) ∧ ∀ (a b : ℤ), 3 * b = 8 - 2 * a → d ∣ (2 * b + 12)} = {1, 2, 4} := by\n    apply Set.Subset.antisymm\n    ·\n      intro d hd\n      have h₁ : d ∈ ({1, 2, 3, 4, 5, 6} : Set ℤ) := hd.1\n      have h₂ : ∀ (a b : ℤ), 3 * b = 8 - 2 * a → d ∣ (2 * b + 12) := hd.2\n      have h₃ : d = 1 ∨ d = 2 ∨ d = 3 ∨ d = 4 ∨ d = 5 ∨ d = 6 := by\n        simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at h₁\n        tauto\n\n      have h₄ : d = 1 ∨ d = 2 ∨ d = 4 := by\n        rcases h₃ with (rfl | rfl | rfl | rfl | rfl | rfl)\n        ·\n          exact Or.inl rfl\n        ·\n          exact Or.inr (Or.inl rfl)\n        ·\n          exfalso\n\n          have h₅ := h₂ 1 2\n          have h₆ : (3 : ℤ) * 2 = 8 - 2 * 1 := by norm_num\n          have h₇ := h₅ h₆\n          norm_num at h₇\n          <;>\n          (try omega) <;>\n          (try {\n            rcases h₇ with ⟨k, hk⟩\n            norm_num at hk\n            <;> omega\n          })\n        ·\n          exact Or.inr (Or.inr rfl)\n        ·\n          exfalso\n\n          have h₅ := h₂ 4 0\n          have h₆ : (3 : ℤ) * 0 = 8 - 2 * 4 := by norm_num\n          have h₇ := h₅ h₆\n          norm_num at h₇\n          <;>\n          (try omega) <;>\n          (try {\n            rcases h₇ with ⟨k, hk⟩\n            norm_num at hk\n            <;> omega\n          })\n        ·\n          exfalso\n\n          have h₅ := h₂ 1 2\n          have h₆ : (3 : ℤ) * 2 = 8 - 2 * 1 := by norm_num\n          have h₇ := h₅ h₆\n          norm_num at h₇\n          <;>\n          (try omega) <;>\n          (try {\n            rcases h₇ with ⟨k, hk⟩\n            norm_num at hk\n            <;> omega\n          })\n\n      rcases h₄ with (rfl | rfl | rfl)\n      ·\n        simp\n      ·\n        simp\n      ·\n        simp\n    ·\n      intro d hd\n      have h₁ : d = 1 ∨ d = 2 ∨ d = 4 := by\n        simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hd\n        tauto\n\n      rcases h₁ with (rfl | rfl | rfl)\n      ·\n        constructor\n        ·\n          norm_num [Set.mem_insert, Set.mem_singleton_iff]\n        ·\n          intro a b h\n          norm_num [Int.emod_eq_of_lt]\n          <;>\n          (try omega) <;>\n          (try {\n            use (2 * b + 12)\n            <;> ring_nf at h ⊢ <;> omega\n          })\n      ·\n        constructor\n        ·\n          norm_num [Set.mem_insert, Set.mem_singleton_iff]\n        ·\n          intro a b h\n          have h₂ : (2 : ℤ) ∣ 2 * b + 12 := by\n            have h₃ : (3 : ℤ) * b = 8 - 2 * a := h\n            have h₄ : (b : ℤ) % 2 = 0 := by\n              have h₅ := congr_arg (· % 2) h₃\n              norm_num at h₅ ⊢\n              <;>\n              (try omega) <;>\n              (try {\n                have h₆ : (a : ℤ) % 2 = 0 ∨ (a : ℤ) % 2 = 1 := by omega\n                rcases h₆ with (h₆ | h₆) <;>\n                simp [h₆, Int.mul_emod, Int.add_emod, Int.sub_emod] at h₅ ⊢ <;>\n                omega\n              })\n\n            have h₅ : (2 : ℤ) ∣ 2 * b + 12 := by\n              have h₆ : (b : ℤ) % 2 = 0 := h₄\n              have h₇ : (2 : ℤ) ∣ b := by\n                omega\n              have h₈ : (2 : ℤ) ∣ 2 * b := by\n                exact dvd_mul_of_dvd_right h₇ 2\n              have h₉ : (2 : ℤ) ∣ 2 * b + 12 := by\n                have h₁₀ : (2 : ℤ) ∣ 12 := by norm_num\n                exact dvd_add h₈ h₁₀\n              exact h₉\n            exact h₅\n          exact h₂\n      ·\n        constructor\n        ·\n          norm_num [Set.mem_insert, Set.mem_singleton_iff]\n        ·\n          intro a b h\n          have h₂ : (4 : ℤ) ∣ 2 * b + 12 := by\n            have h₃ : (3 : ℤ) * b = 8 - 2 * a := h\n            have h₄ : (b : ℤ) % 2 = 0 := by\n              have h₅ := congr_arg (· % 2) h₃\n              norm_num at h₅ ⊢\n              <;>\n              (try omega) <;>\n              (try {\n                have h₆ : (a : ℤ) % 2 = 0 ∨ (a : ℤ) % 2 = 1 := by omega\n                rcases h₆ with (h₆ | h₆) <;>\n                simp [h₆, Int.mul_emod, Int.add_emod, Int.sub_emod] at h₅ ⊢ <;>\n                omega\n              })\n\n            have h₅ : ∃ (k : ℤ), b = 2 * k := by\n              use b / 2\n              have h₆ : (b : ℤ) % 2 = 0 := h₄\n              omega\n            rcases h₅ with ⟨k, rfl⟩\n\n            use k + 3\n            <;> ring_nf at h ⊢ <;>\n            (try omega) <;>\n            (try {\n              nlinarith\n            })\n          exact h₂\n  \n  have h_final : Set.ncard {d : ℤ | d ∈ ({1, 2, 3, 4, 5, 6} : Set ℤ) ∧ ∀ (a b : ℤ), 3 * b = 8 - 2 * a → d ∣ (2 * b + 12)} = 3 := by\n    rw [h_main]\n    norm_num [Set.ncard_insert_of_not_mem, Set.mem_singleton_iff]\n    <;>\n    (try decide) <;>\n    (try {\n      norm_num [Set.ncard_insert_of_not_mem, Set.mem_singleton_iff]\n      <;>\n      decide\n    })\n  \n  exact h_final"}
{"id": "c27", "nl_problem": "For how many real values of $c$ do we have $|3-ci| = 7$?", "formal_type": "Lean", "header": "import Mathlib\ntheorem find_complex_norm_solutions_h1 : ∀ c : ℝ, (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := by\n  intro c\n  have h_main : (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := by\n    apply Complex.ext <;> simp [Complex.ext_iff, Complex.ofReal_re, Complex.ofReal_im, Complex.I_re, Complex.I_im,\n      Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im, Complex.sub_re, Complex.sub_im]\n    <;> ring_nf <;> norm_num <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try ring_nf at *) <;>\n    (try norm_num at *) <;>\n    (try linarith)\n    <;>\n    simp_all [Complex.ext_iff, Complex.ofReal_re, Complex.ofReal_im, Complex.I_re, Complex.I_im,\n      Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im, Complex.sub_re, Complex.sub_im]\n    <;>\n    ring_nf at *\n    <;>\n    norm_num at *\n    <;>\n    linarith\n  \n  exact h_main\ntheorem find_complex_norm_solutions_h2 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ Complex.normSq ((3 : ℂ) - c * Complex.I) = 49 := by\n  intro c\n  constructor\n  · intro h\n    rw [Complex.normSq_eq_norm_sq]\n    rw [h]\n    norm_num\n  · intro h\n    have h_nonneg : 0 ≤ ‖(3 : ℂ) - c * Complex.I‖ := norm_nonneg _\n    rw [Complex.normSq_eq_norm_sq] at h\n    have h_sq : ‖(3 : ℂ) - c * Complex.I‖ ^ 2 = (7 : ℝ) ^ 2 := by\n      rw [h]\n      norm_num\n    have h_seven_sq : (7 : ℝ) ^ 2 = 49 := by norm_num\n    have : ‖(3 : ℂ) - c * Complex.I‖ ^ 2 = 49 := by rw [h_sq, h_seven_sq]\n    have : (‖(3 : ℂ) - c * Complex.I‖ - 7) * (‖(3 : ℂ) - c * Complex.I‖ + 7) = 0 := by\n      nlinarith [sq_nonneg (‖(3 : ℂ) - c * Complex.I‖)]\n    cases' mul_eq_zero.mp this with h1 h2\n    · linarith\n    · linarith\ntheorem find_complex_norm_solutions_h3 : ∀ c : ℝ, Complex.normSq ((3 : ℂ) - c * Complex.I) = 9 + c ^ 2 := by\n  intro c\n  have h : (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := by\n    simp [Complex.ofReal_mul, Complex.I_mul_re, Complex.I_mul_im]\n    ring\n  rw [h, Complex.normSq_add_mul_I]\n  norm_num\ntheorem find_complex_norm_solutions_h4 (h1 : ∀ c : ℝ, (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I) (h2 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ Complex.normSq ((3 : ℂ) - c * Complex.I) = 49) (h3 : ∀ c : ℝ, Complex.normSq ((3 : ℂ) - c * Complex.I) = 9 + c ^ 2) : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ c ^ 2 = 40 := by\n  intro c\n  rw [h2 c]\n  rw [h3 c]\n  constructor\n  · intro h\n    linarith\n  · intro h\n    linarith\ntheorem find_complex_norm_solutions_h5 : {c : ℝ | c ^ 2 = 40} = {2 * Real.sqrt 10, -2 * Real.sqrt 10} := by\n  ext c\n  simp only [Set.mem_setOf, Set.mem_insert_iff, Set.mem_singleton_iff]\n  constructor\n  · intro h\n    have sqrt_40_eq : Real.sqrt 40 = 2 * Real.sqrt 10 := by\n      rw [show (40 : ℝ) = 4 * 10 by norm_num]\n      rw [Real.sqrt_mul (by norm_num : (0 : ℝ) ≤ 4)]\n      norm_num\n    have abs_eq : |c| = 2 * Real.sqrt 10 := by\n      have : Real.sqrt (c ^ 2) = Real.sqrt 40 := by rw [h]\n      rw [Real.sqrt_sq_eq_abs] at this\n      rw [sqrt_40_eq] at this\n      exact this\n    cases' le_or_lt 0 c with hc hc\n    · left\n      have : c = |c| := (abs_of_nonneg hc).symm\n      rw [this, abs_eq]\n    · right\n      have : c = -|c| := by\n        have h1 := abs_of_neg hc\n        linarith\n      rw [this, abs_eq]\n      ring\n  · intro h\n    cases h with\n    | inl h =>\n      rw [h]\n      have sqrt_sq : (Real.sqrt 10 : ℝ) ^ 2 = 10 := Real.sq_sqrt (by norm_num : (0 : ℝ) ≤ 10)\n      calc (2 * Real.sqrt 10) ^ 2 \n          = 2 ^ 2 * (Real.sqrt 10) ^ 2 := by ring\n        _ = 4 * 10 := by rw [sqrt_sq]; norm_num\n        _ = 40 := by norm_num\n    | inr h =>\n      rw [h]\n      have sqrt_sq : (Real.sqrt 10 : ℝ) ^ 2 = 10 := Real.sq_sqrt (by norm_num : (0 : ℝ) ≤ 10)\n      calc (-2 * Real.sqrt 10) ^ 2 \n          = (-2) ^ 2 * (Real.sqrt 10) ^ 2 := by ring\n        _ = 4 * 10 := by rw [sqrt_sq]; norm_num\n        _ = 40 := by norm_num\ntheorem find_complex_norm_solutions_h6 (h5 : {c : ℝ | c ^ 2 = 40} = {2 * Real.sqrt 10, -2 * Real.sqrt 10}) : Set.ncard {c : ℝ | c ^ 2 = 40} = 2 := by\n  have h_sqrt_pos : Real.sqrt 10 > 0 := by\n    exact Real.sqrt_pos.mpr (by norm_num)\n  \n  have h_ne : 2 * Real.sqrt 10 ≠ -2 * Real.sqrt 10 := by\n    intro h\n    have h₁ : Real.sqrt 10 > 0 := h_sqrt_pos\n    have h₂ : 2 * Real.sqrt 10 > 0 := by positivity\n    have h₃ : -2 * Real.sqrt 10 < 0 := by\n      nlinarith [Real.sqrt_nonneg 10]\n    linarith\n  \n  have h_card : Set.ncard ({2 * Real.sqrt 10, -2 * Real.sqrt 10} : Set ℝ) = 2 := by\n    have h₁ : (2 * Real.sqrt 10 : ℝ) ≠ -2 * Real.sqrt 10 := h_ne\n    have h₂ : Set.ncard ({2 * Real.sqrt 10, -2 * Real.sqrt 10} : Set ℝ) = 2 := by\n      -- Use the fact that the two elements are distinct to compute the cardinality\n      have h₃ : Set.ncard ({2 * Real.sqrt 10, -2 * Real.sqrt 10} : Set ℝ) = 2 := by\n        -- Prove that the set has exactly two elements\n        rw [Set.ncard_insert_of_not_mem]\n        · -- Prove that the cardinality of the singleton set is 1\n          simp [Set.mem_singleton_iff, h₁]\n          <;>\n          norm_num\n          <;>\n          linarith [Real.sqrt_pos.mpr (show (0 : ℝ) < 10 by norm_num)]\n        · -- Prove that the element is not in the singleton set\n          simp [Set.mem_singleton_iff, h₁]\n          <;>\n          norm_num\n          <;>\n          linarith [Real.sqrt_pos.mpr (show (0 : ℝ) < 10 by norm_num)]\n      exact h₃\n    exact h₂\n  \n  have h_main : Set.ncard {c : ℝ | c ^ 2 = 40} = 2 := by\n    rw [h5]\n    exact h_card\n  \n  exact h_main\ntheorem find_complex_norm_solutions_h7 (h4 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ c ^ 2 = 40) : {c : ℝ | ‖(3 : ℂ) - c * Complex.I‖ = 7} = {c : ℝ | c ^ 2 = 40} := by\n  ext c\n  exact h4 c\n", "formal_statement": "theorem find_complex_norm_solutions : \n  Set.ncard {c : ℝ | ‖(3 : ℂ) - c * Complex.I‖ = 7} = 2 :=", "formal_code": "import Mathlib\ntheorem find_complex_norm_solutions_h1 : ∀ c : ℝ, (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := by\n  intro c\n  have h_main : (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := by\n    apply Complex.ext <;> simp [Complex.ext_iff, Complex.ofReal_re, Complex.ofReal_im, Complex.I_re, Complex.I_im,\n      Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im, Complex.sub_re, Complex.sub_im]\n    <;> ring_nf <;> norm_num <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try ring_nf at *) <;>\n    (try norm_num at *) <;>\n    (try linarith)\n    <;>\n    simp_all [Complex.ext_iff, Complex.ofReal_re, Complex.ofReal_im, Complex.I_re, Complex.I_im,\n      Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im, Complex.sub_re, Complex.sub_im]\n    <;>\n    ring_nf at *\n    <;>\n    norm_num at *\n    <;>\n    linarith\n  \n  exact h_main\ntheorem find_complex_norm_solutions_h2 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ Complex.normSq ((3 : ℂ) - c * Complex.I) = 49 := by\n  intro c\n  constructor\n  · intro h\n    rw [Complex.normSq_eq_norm_sq]\n    rw [h]\n    norm_num\n  · intro h\n    have h_nonneg : 0 ≤ ‖(3 : ℂ) - c * Complex.I‖ := norm_nonneg _\n    rw [Complex.normSq_eq_norm_sq] at h\n    have h_sq : ‖(3 : ℂ) - c * Complex.I‖ ^ 2 = (7 : ℝ) ^ 2 := by\n      rw [h]\n      norm_num\n    have h_seven_sq : (7 : ℝ) ^ 2 = 49 := by norm_num\n    have : ‖(3 : ℂ) - c * Complex.I‖ ^ 2 = 49 := by rw [h_sq, h_seven_sq]\n    have : (‖(3 : ℂ) - c * Complex.I‖ - 7) * (‖(3 : ℂ) - c * Complex.I‖ + 7) = 0 := by\n      nlinarith [sq_nonneg (‖(3 : ℂ) - c * Complex.I‖)]\n    cases' mul_eq_zero.mp this with h1 h2\n    · linarith\n    · linarith\ntheorem find_complex_norm_solutions_h3 : ∀ c : ℝ, Complex.normSq ((3 : ℂ) - c * Complex.I) = 9 + c ^ 2 := by\n  intro c\n  have h : (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := by\n    simp [Complex.ofReal_mul, Complex.I_mul_re, Complex.I_mul_im]\n    ring\n  rw [h, Complex.normSq_add_mul_I]\n  norm_num\ntheorem find_complex_norm_solutions_h4 (h1 : ∀ c : ℝ, (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I) (h2 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ Complex.normSq ((3 : ℂ) - c * Complex.I) = 49) (h3 : ∀ c : ℝ, Complex.normSq ((3 : ℂ) - c * Complex.I) = 9 + c ^ 2) : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ c ^ 2 = 40 := by\n  intro c\n  rw [h2 c]\n  rw [h3 c]\n  constructor\n  · intro h\n    linarith\n  · intro h\n    linarith\ntheorem find_complex_norm_solutions_h5 : {c : ℝ | c ^ 2 = 40} = {2 * Real.sqrt 10, -2 * Real.sqrt 10} := by\n  ext c\n  simp only [Set.mem_setOf, Set.mem_insert_iff, Set.mem_singleton_iff]\n  constructor\n  · intro h\n    have sqrt_40_eq : Real.sqrt 40 = 2 * Real.sqrt 10 := by\n      rw [show (40 : ℝ) = 4 * 10 by norm_num]\n      rw [Real.sqrt_mul (by norm_num : (0 : ℝ) ≤ 4)]\n      norm_num\n    have abs_eq : |c| = 2 * Real.sqrt 10 := by\n      have : Real.sqrt (c ^ 2) = Real.sqrt 40 := by rw [h]\n      rw [Real.sqrt_sq_eq_abs] at this\n      rw [sqrt_40_eq] at this\n      exact this\n    cases' le_or_lt 0 c with hc hc\n    · left\n      have : c = |c| := (abs_of_nonneg hc).symm\n      rw [this, abs_eq]\n    · right\n      have : c = -|c| := by\n        have h1 := abs_of_neg hc\n        linarith\n      rw [this, abs_eq]\n      ring\n  · intro h\n    cases h with\n    | inl h =>\n      rw [h]\n      have sqrt_sq : (Real.sqrt 10 : ℝ) ^ 2 = 10 := Real.sq_sqrt (by norm_num : (0 : ℝ) ≤ 10)\n      calc (2 * Real.sqrt 10) ^ 2 \n          = 2 ^ 2 * (Real.sqrt 10) ^ 2 := by ring\n        _ = 4 * 10 := by rw [sqrt_sq]; norm_num\n        _ = 40 := by norm_num\n    | inr h =>\n      rw [h]\n      have sqrt_sq : (Real.sqrt 10 : ℝ) ^ 2 = 10 := Real.sq_sqrt (by norm_num : (0 : ℝ) ≤ 10)\n      calc (-2 * Real.sqrt 10) ^ 2 \n          = (-2) ^ 2 * (Real.sqrt 10) ^ 2 := by ring\n        _ = 4 * 10 := by rw [sqrt_sq]; norm_num\n        _ = 40 := by norm_num\ntheorem find_complex_norm_solutions_h6 (h5 : {c : ℝ | c ^ 2 = 40} = {2 * Real.sqrt 10, -2 * Real.sqrt 10}) : Set.ncard {c : ℝ | c ^ 2 = 40} = 2 := by\n  have h_sqrt_pos : Real.sqrt 10 > 0 := by\n    exact Real.sqrt_pos.mpr (by norm_num)\n  \n  have h_ne : 2 * Real.sqrt 10 ≠ -2 * Real.sqrt 10 := by\n    intro h\n    have h₁ : Real.sqrt 10 > 0 := h_sqrt_pos\n    have h₂ : 2 * Real.sqrt 10 > 0 := by positivity\n    have h₃ : -2 * Real.sqrt 10 < 0 := by\n      nlinarith [Real.sqrt_nonneg 10]\n    linarith\n  \n  have h_card : Set.ncard ({2 * Real.sqrt 10, -2 * Real.sqrt 10} : Set ℝ) = 2 := by\n    have h₁ : (2 * Real.sqrt 10 : ℝ) ≠ -2 * Real.sqrt 10 := h_ne\n    have h₂ : Set.ncard ({2 * Real.sqrt 10, -2 * Real.sqrt 10} : Set ℝ) = 2 := by\n\n      have h₃ : Set.ncard ({2 * Real.sqrt 10, -2 * Real.sqrt 10} : Set ℝ) = 2 := by\n\n        rw [Set.ncard_insert_of_not_mem]\n        ·\n          simp [Set.mem_singleton_iff, h₁]\n          <;>\n          norm_num\n          <;>\n          linarith [Real.sqrt_pos.mpr (show (0 : ℝ) < 10 by norm_num)]\n        ·\n          simp [Set.mem_singleton_iff, h₁]\n          <;>\n          norm_num\n          <;>\n          linarith [Real.sqrt_pos.mpr (show (0 : ℝ) < 10 by norm_num)]\n      exact h₃\n    exact h₂\n  \n  have h_main : Set.ncard {c : ℝ | c ^ 2 = 40} = 2 := by\n    rw [h5]\n    exact h_card\n  \n  exact h_main\ntheorem find_complex_norm_solutions_h7 (h4 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ c ^ 2 = 40) : {c : ℝ | ‖(3 : ℂ) - c * Complex.I‖ = 7} = {c : ℝ | c ^ 2 = 40} := by\n  ext c\n  exact h4 c\ntheorem find_complex_norm_solutions : \n  Set.ncard {c : ℝ | ‖(3 : ℂ) - c * Complex.I‖ = 7} = 2 := by\n  have h1 : ∀ c : ℝ, (3 : ℂ) - c * Complex.I = Complex.ofReal 3 + Complex.ofReal (-c) * Complex.I := \n    find_complex_norm_solutions_h1\n  have h2 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ Complex.normSq ((3 : ℂ) - c * Complex.I) = 49 := \n    find_complex_norm_solutions_h2\n  have h3 : ∀ c : ℝ, Complex.normSq ((3 : ℂ) - c * Complex.I) = 9 + c ^ 2 := \n    find_complex_norm_solutions_h3\n  have h4 : ∀ c : ℝ, ‖(3 : ℂ) - c * Complex.I‖ = 7 ↔ c ^ 2 = 40 := \n    find_complex_norm_solutions_h4 h1 h2 h3\n  have h5 : {c : ℝ | c ^ 2 = 40} = {2 * Real.sqrt 10, -2 * Real.sqrt 10} := \n    find_complex_norm_solutions_h5\n  have h6 : Set.ncard {c : ℝ | c ^ 2 = 40} = 2 := \n    find_complex_norm_solutions_h6 h5\n  have h7 : {c : ℝ | ‖(3 : ℂ) - c * Complex.I‖ = 7} = {c : ℝ | c ^ 2 = 40} := \n    find_complex_norm_solutions_h7 h4\n  calc Set.ncard {c : ℝ | ‖(3 : ℂ) - c * Complex.I‖ = 7}\n      = Set.ncard {c : ℝ | c ^ 2 = 40} := by rw [h7]\n    _ = 2 := h6"}
