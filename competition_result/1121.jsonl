{"id": "c76", "nl_problem": "A graph is defined in polar coordinates by $r = \\cos \\theta + \\frac{1}{2}.$  Find the smallest $x$-coordinate of any point on this graph.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem polar_graph_min_x : \n  let S := {x : ℝ | ∃ θ : ℝ, x = (Real.cos θ + 1/2) * Real.cos θ}\n  IsMinOn (fun x => x) S (-1/16) :=", "formal_code": "import Mathlib\ntheorem polar_graph_min_x : \n  let S := {x : ℝ | ∃ θ : ℝ, x = (Real.cos θ + 1/2) * Real.cos θ}\n  IsMinOn (fun x => x) S (-1/16) := by\n  rw [isMinOn_iff]\n  intro x ⟨θ, hx⟩\n  rw [hx]\n  set u := Real.cos θ with hu_def\n  have hu_bounds := Real.cos_mem_Icc θ\n  -- We need to show: -1/16 ≤ (u + 1/2) * u\n  -- Equivalently: 0 ≤ u² + u/2 + 1/16 = (u + 1/4)²\n  have key : 0 ≤ (u + 1/4)^2 := sq_nonneg _\n  nlinarith [sq_nonneg (u + 1/4)]"}
{"id": "c675", "nl_problem": "Let $a,$ $b,$ $c$ be real numbers such that $a + b + c = 0.$  Find the set of all possible values of $ab + ac + bc.$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem compute_symmetric_sum_range : \n  {x : ℝ | ∃ a b c : ℝ, a + b + c = 0 ∧ x = a * b + a * c + b * c} = Set.Iic 0 :=", "formal_code": "import Mathlib\ntheorem compute_symmetric_sum_range : \n  {x : ℝ | ∃ a b c : ℝ, a + b + c = 0 ∧ x = a * b + a * c + b * c} = Set.Iic 0 := by\n  ext x\n  simp only [Set.mem_setOf, Set.mem_Iic]\n  constructor\n  · -- Forward direction: if x is in the set, then x ≤ 0\n    intro ⟨a, b, c, habc, hx⟩\n    rw [hx]\n    -- Use the identity (a+b+c)² = a² + b² + c² + 2(ab+ac+bc)\n    have h_sq : (a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + a * c + b * c) := by ring\n    rw [habc] at h_sq\n    simp at h_sq\n    -- From h_sq: 0 = a² + b² + c² + 2(ab+ac+bc)\n    -- So: ab+ac+bc = -(a²+b²+c²)/2\n    have h_nonneg : 0 ≤ a ^ 2 + b ^ 2 + c ^ 2 := by\n      apply add_nonneg\n      apply add_nonneg\n      · exact sq_nonneg a\n      · exact sq_nonneg b\n      · exact sq_nonneg c\n    linarith\n  · -- Backward direction: if x ≤ 0, then x is in the set\n    intro hx\n    -- Construct a = √(-x), b = -√(-x), c = 0\n    use Real.sqrt (-x), -Real.sqrt (-x), 0\n    constructor\n    · -- Verify a + b + c = 0\n      simp [add_assoc]\n    · -- Verify ab + ac + bc = x\n      simp only [mul_zero, add_zero]\n      have h_nonneg : 0 ≤ -x := by linarith\n      have h_sqrt_sq : (Real.sqrt (-x)) ^ 2 = -x := Real.sq_sqrt h_nonneg\n      ring_nf\n      rw [h_sqrt_sq]\n      ring"}
{"id": "c113", "nl_problem": "For a finite sequence $A=(a_1,a_2,\\dots,a_n)$ of numbers, the Cesaro sum of $A$ is defined to be\n\\[\\frac{S_1+\\cdots+S_n}{n},\\]where $S_k=a_1+\\cdots+a_k$ and $1\\leq k\\leq n$.\n\nIf the Cesaro sum of the 99-term sequence $(a_1,\\dots,a_{99})$ is 1000,  what is the Cesaro sum of the 100-term sequence $(1,a_1,\\dots,a_{99})$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem cesaro_sum_invariant (a : List ℚ) (ha : a.length = 99) :\n  let S := fun (xs : List ℚ) (k : ℕ) => (xs.take k).sum\n  let C := fun (xs : List ℚ) => ((Finset.range xs.length).sum (fun k => S xs (k + 1))) / xs.length\n  C a = 1000 → C (1 :: a) = 991 :=", "formal_code": "import Mathlib\ntheorem cesaro_sum_invariant (a : List ℚ) (ha : a.length = 99) :\n  let S := fun (xs : List ℚ) (k : ℕ) => (xs.take k).sum\n  let C := fun (xs : List ℚ) => ((Finset.range xs.length).sum (fun k => S xs (k + 1))) / xs.length\n  C a = 1000 → C (1 :: a) = 991 := by\n  intro S C hC\n  have h₁ : a.length = 99 := ha\n  have h₂ : C a = 1000 := hC\n  have h₃ : C (1 :: a) = 991 := by\n    have h₄ : C a = ((Finset.range a.length).sum (fun k => S a (k + 1))) / a.length := rfl\n    rw [h₄] at h₂\n    have h₅ : a.length = 99 := h₁\n    rw [h₅] at h₂\n    have h₆ : ((Finset.range 99).sum (fun k => S a (k + 1))) / 99 = 1000 := by simpa using h₂\n    have h₇ : ((Finset.range 99).sum (fun k => S a (k + 1))) = 99000 := by\n      norm_num at h₆ ⊢\n      <;> linarith\n    have h₈ : C (1 :: a) = ((Finset.range (1 :: a).length).sum (fun k => S (1 :: a) (k + 1))) / (1 :: a).length := rfl\n    rw [h₈]\n    have h₉ : (1 :: a).length = 100 := by\n      simp [h₁]\n      <;> norm_num\n    rw [h₉]\n    have h₁₀ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n      have h₁₁ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n      rw [h₁₁]\n      have h₁₂ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n        -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n        have h₁₃ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n        rw [h₁₃]\n        -- Use the fact that S (1 :: a) (k + 1) is 1 + sum of the first k elements of a for k ≥ 1\n        have h₁₄ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n          -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n          calc\n            ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n            _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n              -- Use the fact that S (1 :: a) (k + 1) is 1 + sum of the first k elements of a for k ≥ 1\n              have h₁₅ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n                calc\n                  ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n                  _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                    -- Use the fact that S (1 :: a) (k + 1) is 1 + sum of the first k elements of a for k ≥ 1\n                    have h₁₆ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                      -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n                      calc\n                        ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n                        _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                          -- Use the fact that S (1 :: a) (k + 1) is 1 + sum of the first k elements of a for k ≥ 1\n                          have h₁₇ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                            -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n                            calc\n                              ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n                              _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                                -- Use the fact that S (1 :: a) (k + 1) is 1 + sum of the first k elements of a for k ≥ 1\n                                have h₁₈ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                                  -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n                                  calc\n                                    ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) := rfl\n                                    _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                                      -- Use the fact that S (1 :: a) (k + 1) is 1 + sum of the first k elements of a for k ≥ 1\n                                      have h₁₉ : ((Finset.range 100).sum (fun k => S (1 :: a) (k + 1))) = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by\n                                        -- Prove that the sum of S (1 :: a) (k + 1) over k from 0 to 99 is 100 + sum of S a (k + 1) over k from 0 to 98\n                                        simp [Finset.sum_range_succ, S, List.take, List.sum_cons, List.sum_nil, Nat.cast_add, Nat.cast_one, Nat.cast_zero]\n                                        <;>\n                                        (try decide) <;>\n                                        (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n                                        (try simp_all [Finset.sum_range_succ, S, List.take, List.sum_cons, List.sum_nil, Nat.cast_add, Nat.cast_one, Nat.cast_zero]) <;>\n                                        (try ring_nf at * <;> norm_num at * <;> linarith)\n                                      exact h₁₉\n                                exact h₁₈\n                              _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by rfl\n                          exact h₁₇\n                        _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by rfl\n                    exact h₁₆\n                  _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by rfl\n              exact h₁₅\n            _ = 100 + ((Finset.range 99).sum (fun k => S a (k + 1))) := by rfl\n        exact h₁₄\n      exact h₁₂\n    rw [h₁₀]\n    rw [h₇]\n    <;> norm_num\n    <;> field_simp\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  exact h₃"}
{"id": "c372", "nl_problem": "For $-25 \\le x \\le 25,$ find the maximum value of $\\sqrt{25 + x} + \\sqrt{25 - x}.$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem max_function_value : \n  let f : ℝ → ℝ := fun x => Real.sqrt (25 + x) + Real.sqrt (25 - x)\n  (∀ x ∈ Set.Icc (-25) 25, f x ≤ 10) ∧ \n  (∃ x ∈ Set.Icc (-25) 25, f x = 10) :=", "formal_code": "import Mathlib\ntheorem max_function_value : \n  let f : ℝ → ℝ := fun x => Real.sqrt (25 + x) + Real.sqrt (25 - x)\n  (∀ x ∈ Set.Icc (-25) 25, f x ≤ 10) ∧ \n  (∃ x ∈ Set.Icc (-25) 25, f x = 10) := by\n  intro f\n  have h₁ : ∀ x ∈ Set.Icc (-25) 25, f x ≤ 10 := by\n    intro x hx\n    have h₂ : -25 ≤ x := by exact hx.1\n    have h₃ : x ≤ 25 := by exact hx.2\n    have h₄ : 0 ≤ Real.sqrt (25 + x) := Real.sqrt_nonneg (25 + x)\n    have h₅ : 0 ≤ Real.sqrt (25 - x) := Real.sqrt_nonneg (25 - x)\n    have h₆ : 0 ≤ Real.sqrt (25 + x) * Real.sqrt (25 - x) := by positivity\n    have h₇ : (Real.sqrt (25 + x) + Real.sqrt (25 - x)) ^ 2 ≤ 100 := by\n      nlinarith [Real.sq_sqrt (show 0 ≤ 25 + x by linarith), Real.sq_sqrt (show 0 ≤ 25 - x by linarith),\n        sq_nonneg (Real.sqrt (25 + x) - Real.sqrt (25 - x))]\n    have h₈ : Real.sqrt (25 + x) + Real.sqrt (25 - x) ≤ 10 := by\n      nlinarith [Real.sqrt_nonneg (25 + x), Real.sqrt_nonneg (25 - x), Real.sq_sqrt (show 0 ≤ 25 + x by linarith),\n        Real.sq_sqrt (show 0 ≤ 25 - x by linarith)]\n    simpa [f] using h₈\n  \n  have h₂ : ∃ x ∈ Set.Icc (-25) 25, f x = 10 := by\n    use 0\n    constructor\n    · -- Prove that 0 is in the interval [-25, 25]\n      constructor <;> norm_num\n    · -- Prove that f(0) = 10\n      have h₃ : f 0 = 10 := by\n        have h₄ : f 0 = Real.sqrt (25 + (0 : ℝ)) + Real.sqrt (25 - (0 : ℝ)) := rfl\n        rw [h₄]\n        norm_num\n      exact h₃\n  \n  exact ⟨h₁, h₂⟩"}
{"id": "c626", "nl_problem": "For real numbers $x,$ $y,$ and $z,$ find the minimum value of\n\\[2x^2 + 5y^2 + 2z^2 + 4xy - 4yz - 2z - 2x.\\]", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem minimize_quadratic_expression : \n  let f := fun (x y z : ℝ) => 2*x^2 + 5*y^2 + 2*z^2 + 4*x*y - 4*y*z - 2*z - 2*x\n  (∃ x₀ y₀ z₀ : ℝ, f x₀ y₀ z₀ = -1) ∧ \n  (∀ x y z : ℝ, -1 ≤ f x y z) :=", "formal_code": "import Mathlib\ntheorem minimize_quadratic_expression : \n  let f := fun (x y z : ℝ) => 2*x^2 + 5*y^2 + 2*z^2 + 4*x*y - 4*y*z - 2*z - 2*x\n  (∃ x₀ y₀ z₀ : ℝ, f x₀ y₀ z₀ = -1) ∧ \n  (∀ x y z : ℝ, -1 ≤ f x y z) := by\n  constructor\n  · -- First part: existence of minimum point\n    use 1/2, 0, 1/2\n    norm_num\n  · -- Second part: lower bound\n    intro x y z\n    -- We show that f(x,y,z) + 1 ≥ 0 by completing the square\n    let u := x - 1/2\n    let v := y\n    let w := z - 1/2\n    \n    -- The key algebraic identity: the quadratic form can be written as sum of squares\n    have key : 2*u^2 + 5*v^2 + 2*w^2 + 4*u*v - 4*v*w = \n               2*(u + v)^2 + v^2 + 2*(w - v)^2 := by ring\n    \n    -- Show that the sum of squares is nonnegative\n    have nonneg : 0 ≤ 2*(u + v)^2 + v^2 + 2*(w - v)^2 := by\n      apply add_nonneg\n      apply add_nonneg\n      · exact mul_nonneg (by norm_num : (0 : ℝ) ≤ 2) (sq_nonneg _)\n      · exact sq_nonneg _\n      · exact mul_nonneg (by norm_num : (0 : ℝ) ≤ 2) (sq_nonneg _)\n    \n    -- Connect the original function to the sum of squares form\n    have h : 2*x^2 + 5*y^2 + 2*z^2 + 4*x*y - 4*y*z - 2*z - 2*x = \n             2*u^2 + 5*v^2 + 2*w^2 + 4*u*v - 4*v*w - 1 := by ring\n    \n    -- Combine: original = (sum of squares) - 1, and sum of squares ≥ 0\n    rw [← key] at nonneg\n    linarith"}
{"id": "c44", "nl_problem": "Suppose that $f(x)$ is a function such that\n\\[f(xy) + x = xf(y) + f(x)\\]for all real numbers $x$ and $y.$  If $f(-1) = 5$ then compute $f(-1001).$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem functional_equation_solution (f : ℝ → ℝ) \n  (h1 : ∀ x y : ℝ, f (x * y) + x = x * f y + f x)\n  (h2 : f (-1) = 5) : \n  f (-1001) = 2005 :=", "formal_code": "import Mathlib\ntheorem functional_equation_solution (f : ℝ → ℝ) \n  (h1 : ∀ x y : ℝ, f (x * y) + x = x * f y + f x)\n  (h2 : f (-1) = 5) : \n  f (-1001) = 2005 := by\n  have h_f1 : f 1 = 1 := by\n    have h3 := h1 1 1\n    have h4 := h1 0 1\n    have h5 := h1 1 0\n    have h6 := h1 (-1) 1\n    have h7 := h1 1 (-1)\n    have h8 := h1 (-1) (-1)\n    have h9 := h1 2 1\n    have h10 := h1 1 2\n    have h11 := h1 (-2) 1\n    have h12 := h1 1 (-2)\n    have h13 := h1 (-2) (-1)\n    have h14 := h1 (-1) (-2)\n    norm_num at h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 ⊢\n    <;>\n    (try linarith) <;>\n    (try nlinarith) <;>\n    (try\n      {\n        nlinarith [h1 0 0, h1 1 0, h1 0 1, h1 2 0, h1 0 2, h1 2 2, h1 (-2) 0, h1 0 (-2), h1 (-2) (-2)]\n      }) <;>\n    (try\n      {\n        nlinarith [h1 0 0, h1 1 0, h1 0 1, h1 2 0, h1 0 2, h1 2 2, h1 (-2) 0, h1 0 (-2), h1 (-2) (-2)]\n      }) <;>\n    (try\n      {\n        nlinarith [h1 0 0, h1 1 0, h1 0 1, h1 2 0, h1 0 2, h1 2 2, h1 (-2) 0, h1 0 (-2), h1 (-2) (-2)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [h1 0 0, h1 1 0, h1 0 1, h1 2 0, h1 0 2, h1 2 2, h1 (-2) 0, h1 0 (-2), h1 (-2) (-2)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [h1 0 0, h1 1 0, h1 0 1, h1 2 0, h1 0 2, h1 2 2, h1 (-2) 0, h1 0 (-2), h1 (-2) (-2)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [h1 0 0, h1 1 0, h1 0 1, h1 2 0, h1 0 2, h1 2 2, h1 (-2) 0, h1 0 (-2), h1 (-2) (-2)]\n      })\n  \n  have h_f0 : f 0 = 3 := by\n    have h3 := h1 (-1) 0\n    have h4 := h1 0 (-1)\n    have h5 := h1 1 0\n    have h6 := h1 0 1\n    have h7 := h1 (-1) 1\n    have h8 := h1 1 (-1)\n    have h9 := h1 (-1) (-1)\n    have h10 := h1 2 0\n    have h11 := h1 0 2\n    have h12 := h1 2 2\n    have h13 := h1 (-2) 0\n    have h14 := h1 0 (-2)\n    have h15 := h1 (-2) (-2)\n    norm_num [h_f1, h2] at h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 ⊢\n    <;> nlinarith\n  \n  have h_f1001 : f 1001 = -1999 := by\n    have h3 := h1 1001 (-1)\n    have h4 := h1 (-1) 1001\n    have h5 := h1 1001 1\n    have h6 := h1 1 1001\n    have h7 := h1 (-1001) 1\n    have h8 := h1 1 (-1001)\n    have h9 := h1 (-1001) (-1)\n    have h10 := h1 (-1) (-1001)\n    norm_num [h_f1, h_f0, h2] at h3 h4 h5 h6 h7 h8 h9 h10 ⊢\n    <;> nlinarith\n  \n  have h_main : f (-1001) = 2005 := by\n    have h3 := h1 (-1) 1001\n    have h4 := h1 1001 (-1)\n    have h5 := h1 (-1001) 1\n    have h6 := h1 1 (-1001)\n    have h7 := h1 (-1001) (-1)\n    have h8 := h1 (-1) (-1001)\n    norm_num [h_f1, h_f0, h_f1001, h2] at h3 h4 h5 h6 h7 h8 ⊢\n    <;> nlinarith\n  \n  exact h_main"}
{"id": "c208", "nl_problem": "A parabola $ax^2+bx+c$ contains the points $(-1,0)$, $(0,5)$, and $(5,0)$.  Find the value $100a+10b+c$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem parabola_coefficient_evaluation (a b c : ℝ) \n  (h1 : a * (-1)^2 + b * (-1) + c = 0)\n  (h2 : a * 0^2 + b * 0 + c = 5)\n  (h3 : a * 5^2 + b * 5 + c = 0)\n  : 100 * a + 10 * b + c = -55 :=", "formal_code": "import Mathlib\ntheorem parabola_coefficient_evaluation (a b c : ℝ) \n  (h1 : a * (-1)^2 + b * (-1) + c = 0)\n  (h2 : a * 0^2 + b * 0 + c = 5)\n  (h3 : a * 5^2 + b * 5 + c = 0)\n  : 100 * a + 10 * b + c = -55 := by\n  -- From h2, we get c = 5\n  have hc : c = 5 := by norm_num at h2; exact h2\n  \n  -- Simplify h1 using ring and norm_num\n  have h1_simp : a - b + c = 0 := by\n    have : a * (-1)^2 + b * (-1) + c = a - b + c := by ring\n    rw [this] at h1\n    exact h1\n  \n  -- Simplify h3 using ring and norm_num\n  have h3_simp : 25 * a + 5 * b + c = 0 := by\n    have : a * 5^2 + b * 5 + c = 25 * a + 5 * b + c := by ring\n    rw [this] at h3\n    exact h3\n  \n  -- Substitute c = 5 into h1_simp: a - b + 5 = 0, so a - b = -5\n  have eq_a : a - b = -5 := by\n    rw [hc] at h1_simp\n    linarith\n  \n  -- Substitute c = 5 into h3_simp: 25*a + 5*b + 5 = 0, so 5*a + b = -1\n  have eq_b : 5 * a + b = -1 := by\n    rw [hc] at h3_simp\n    linarith\n  \n  -- Solve for a: from eq_a and eq_b, we get a = -1\n  have ha : a = -1 := by linarith\n  \n  -- Solve for b: from eq_a and a = -1, we get b = 4\n  have hb : b = 4 := by linarith\n  \n  -- Substitute a = -1, b = 4, c = 5 into the target expression\n  rw [ha, hb, hc]\n  norm_num"}
