{"id": "c1605", "nl_problem": "Prove that for any non-zero natural number \\( n \\), multiplying the cardinality of the continuum (\\( \\mathfrak{c} \\)) by \\( n \\) still results in the cardinality of the continuum.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem cardinality_multiplication_invariance : âˆ€ n : â„•, n â‰  0 â†’ (n : Cardinal) * Cardinal.continuum = Cardinal.continuum :=", "formal_code": "import Mathlib\ntheorem cardinality_multiplication_invariance : âˆ€ n : â„•, n â‰  0 â†’ (n : Cardinal) * Cardinal.continuum = Cardinal.continuum := by\n  intro n hn\n  cases n with\n  | zero =>\n    -- This case is impossible because hn : n â‰  0\n    exfalso\n    exact hn rfl\n  | succ n =>\n    cases n with\n    | zero =>\n      -- Case n = 1\n      simp [one_mul]\n    | succ n =>\n      -- Case n â‰¥ 2\n      have h_comm : (n.succ.succ : Cardinal) * Cardinal.continuum = Cardinal.continuum * (n.succ.succ : Cardinal) := by\n        exact mul_comm _ _\n      rw [h_comm]\n      -- Now we need to apply Cardinal.continuum_mul_ofNat\n      -- First, we need to show that n.succ.succ â‰¥ 2\n      have h_at_least_two : Nat.AtLeastTwo (n.succ.succ) := by\n        constructor\n        norm_num\n      exact Cardinal.continuum_mul_ofNat (n := n.succ.succ)"}
{"id": "c132", "nl_problem": "Find the roots of\n\\[6x^4 - 35x^3 + 62x^2 - 35x + 6 = 0.\\]Enter the roots, separated by commas.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem polynomial_real_roots_set : \n  {x : â„ | 6 * x^4 - 35 * x^3 + 62 * x^2 - 35 * x + 6 = 0} = {3, 1/3, 2, 1/2} :=", "formal_code": "import Mathlib\ntheorem polynomial_real_roots_set : \n  {x : â„ | 6 * x^4 - 35 * x^3 + 62 * x^2 - 35 * x + 6 = 0} = {3, 1/3, 2, 1/2} := by\n  have h_main : âˆ€ (x : â„), 6 * x ^ 4 - 35 * x ^ 3 + 62 * x ^ 2 - 35 * x + 6 = (x - 3) * (x - 2) * (2 * x - 1) * (3 * x - 1) := by\n    intro x\n    ring_nf\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try linarith)\n    <;>\n    (try nlinarith)\n  \n  have h_subsetâ‚ : {x : â„ | 6 * x ^ 4 - 35 * x ^ 3 + 62 * x ^ 2 - 35 * x + 6 = 0} âŠ† {3, 1/3, 2, 1/2} := by\n    intro x hx\n    have hâ‚ : 6 * x ^ 4 - 35 * x ^ 3 + 62 * x ^ 2 - 35 * x + 6 = 0 := hx\n    have hâ‚‚ : (x - 3) * (x - 2) * (2 * x - 1) * (3 * x - 1) = 0 := by\n      have hâ‚ƒ := h_main x\n      linarith\n    have hâ‚ƒ : x - 3 = 0 âˆ¨ x - 2 = 0 âˆ¨ 2 * x - 1 = 0 âˆ¨ 3 * x - 1 = 0 := by\n      have hâ‚„ : (x - 3) = 0 âˆ¨ (x - 2) = 0 âˆ¨ (2 * x - 1) = 0 âˆ¨ (3 * x - 1) = 0 := by\n        -- Use the fact that if a product of four terms is zero, at least one of them must be zero.\n        have hâ‚… : (x - 3) * (x - 2) * (2 * x - 1) * (3 * x - 1) = 0 := hâ‚‚\n        have hâ‚† : (x - 3) = 0 âˆ¨ (x - 2) = 0 âˆ¨ (2 * x - 1) = 0 âˆ¨ (3 * x - 1) = 0 := by\n          -- Use the fact that if a product of four terms is zero, at least one of them must be zero.\n          simp [sub_eq_zero] at hâ‚… âŠ¢\n          -- Use the fact that if a product of four terms is zero, at least one of them must be zero.\n          <;>\n          (try\n            {\n              aesop\n            })\n          <;>\n          (try\n            {\n              by_cases hâ‚‡ : x - 3 = 0 <;>\n              by_cases hâ‚ˆ : x - 2 = 0 <;>\n              by_cases hâ‚‰ : 2 * x - 1 = 0 <;>\n              by_cases hâ‚â‚€ : 3 * x - 1 = 0 <;>\n              simp_all [sub_eq_zero] <;>\n              (try { nlinarith }) <;>\n              (try { linarith }) <;>\n              (try { nlinarith }) <;>\n              (try { linarith })\n            })\n          <;>\n          (try\n            {\n              aesop\n            })\n        exact hâ‚†\n      exact hâ‚„\n    -- Now we know that at least one of the factors is zero, we can deduce the possible values of x.\n    have hâ‚„ : x = 3 âˆ¨ x = 2 âˆ¨ x = 1 / 2 âˆ¨ x = 1 / 3 := by\n      cases hâ‚ƒ with\n      | inl hâ‚ƒ =>\n        -- Case: x - 3 = 0\n        have hâ‚… : x = 3 := by linarith\n        exact Or.inl hâ‚…\n      | inr hâ‚ƒ =>\n        cases hâ‚ƒ with\n        | inl hâ‚ƒ =>\n          -- Case: x - 2 = 0\n          have hâ‚… : x = 2 := by linarith\n          exact Or.inr (Or.inl hâ‚…)\n        | inr hâ‚ƒ =>\n          cases hâ‚ƒ with\n          | inl hâ‚ƒ =>\n            -- Case: 2 * x - 1 = 0\n            have hâ‚… : x = 1 / 2 := by\n              have hâ‚† : 2 * x - 1 = 0 := hâ‚ƒ\n              linarith\n            exact Or.inr (Or.inr (Or.inl hâ‚…))\n          | inr hâ‚ƒ =>\n            -- Case: 3 * x - 1 = 0\n            have hâ‚… : x = 1 / 3 := by\n              have hâ‚† : 3 * x - 1 = 0 := hâ‚ƒ\n              linarith\n            exact Or.inr (Or.inr (Or.inr hâ‚…))\n    -- Now we know that x is one of the four values, we can conclude that x is in the set {3, 1/3, 2, 1/2}.\n    have hâ‚… : x = 3 âˆ¨ x = 1 / 3 âˆ¨ x = 2 âˆ¨ x = 1 / 2 := by\n      cases hâ‚„ with\n      | inl hâ‚„ =>\n        -- Case: x = 3\n        exact Or.inl hâ‚„\n      | inr hâ‚„ =>\n        cases hâ‚„ with\n        | inl hâ‚„ =>\n          -- Case: x = 2\n          exact Or.inr (Or.inr (Or.inl hâ‚„))\n        | inr hâ‚„ =>\n          cases hâ‚„ with\n          | inl hâ‚„ =>\n            -- Case: x = 1 / 2\n            exact Or.inr (Or.inr (Or.inr hâ‚„))\n          | inr hâ‚„ =>\n            -- Case: x = 1 / 3\n            exact Or.inr (Or.inl hâ‚„)\n    -- Now we can conclude that x is in the set {3, 1/3, 2, 1/2}.\n    have hâ‚† : x âˆˆ ({3, 1 / 3, 2, 1 / 2} : Set â„) := by\n      rcases hâ‚… with (rfl | rfl | rfl | rfl) <;> norm_num <;>\n        (try { contradiction }) <;>\n        (try { aesop }) <;>\n        (try { norm_num }) <;>\n        (try { linarith })\n    exact hâ‚†\n  \n  have h_subsetâ‚‚ : {3, 1/3, 2, 1/2} âŠ† {x : â„ | 6 * x ^ 4 - 35 * x ^ 3 + 62 * x ^ 2 - 35 * x + 6 = 0} := by\n    intro x hx\n    simp only [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq] at hx âŠ¢\n    rcases hx with (rfl | rfl | rfl | rfl)\n    Â· -- Case x = 3\n      norm_num\n    Â· -- Case x = 1/3\n      norm_num\n    Â· -- Case x = 2\n      norm_num\n    Â· -- Case x = 1/2\n      norm_num\n  \n  have h_final : {x : â„ | 6 * x ^ 4 - 35 * x ^ 3 + 62 * x ^ 2 - 35 * x + 6 = 0} = {3, 1/3, 2, 1/2} := by\n    apply Set.Subset.antisymm\n    Â· -- Prove the first subset relation\n      exact h_subsetâ‚\n    Â· -- Prove the second subset relation\n      exact h_subsetâ‚‚\n  \n  exact h_final"}
{"id": "c1739", "nl_problem": "Prove that the determinant of an invertible matrix is a unit (i.e., has a multiplicative inverse).", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem matrix_determinant_unit (R : Type*) [CommRing R] (n : â„•) (A : Matrix (Fin n) (Fin n) R) \n  (hA : IsUnit A) : IsUnit (Matrix.det A) :=", "formal_code": "import Mathlib\ntheorem matrix_determinant_unit (R : Type*) [CommRing R] (n : â„•) (A : Matrix (Fin n) (Fin n) R) \n  (hA : IsUnit A) : IsUnit (Matrix.det A) := by\n  exact (Matrix.isUnit_iff_isUnit_det A).mp hA"}
{"id": "c491", "nl_problem": "Let $\\mathbf{A} =\\begin{pmatrix}  -1 & 2 \\\\  3 & 4  \\end{pmatrix}.$  Then there exist scalars $p$ and $q$ such that\n\\[\\mathbf{A}^6 = p \\mathbf{A} + q \\mathbf{I}.\\]Enter the ordered pair $(p,q).$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem matrix_polynomial_identity_coefficients : \n  let A : Matrix (Fin 2) (Fin 2) â„¤ := !![-1, 2; 3, 4]\n  let I : Matrix (Fin 2) (Fin 2) â„¤ := 1\n  A^6 = (2223 : â„¤) â€¢ A + (4510 : â„¤) â€¢ I :=", "formal_code": "import Mathlib\ntheorem matrix_polynomial_identity_coefficients : \n  let A : Matrix (Fin 2) (Fin 2) â„¤ := !![-1, 2; 3, 4]\n  let I : Matrix (Fin 2) (Fin 2) â„¤ := 1\n  A^6 = (2223 : â„¤) â€¢ A + (4510 : â„¤) â€¢ I := by\n  decide"}
{"id": "c1388", "nl_problem": "Show that $[0,1]$ is a retract of $\\mathbb{R}$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem continuous_unit_interval_identity : âˆƒ r : â„ â†’ â„, Continuous r âˆ§ \n  (âˆ€ x, r x âˆˆ Set.Icc 0 1) âˆ§ \n  (âˆ€ x âˆˆ Set.Icc 0 1, r x = x) :=", "formal_code": "import Mathlib\ntheorem continuous_unit_interval_identity : âˆƒ r : â„ â†’ â„, Continuous r âˆ§ \n  (âˆ€ x, r x âˆˆ Set.Icc 0 1) âˆ§ \n  (âˆ€ x âˆˆ Set.Icc 0 1, r x = x) := by\n  have h_main : âˆƒ (r : â„ â†’ â„), Continuous r âˆ§ (âˆ€ x, r x âˆˆ Set.Icc 0 1) âˆ§ (âˆ€ x âˆˆ Set.Icc 0 1, r x = x) := by\n    use fun x => max 0 (min x 1)\n    constructor\n    Â· -- Prove that the function is continuous\n      apply Continuous.max\n      Â· exact continuous_const\n      Â· apply Continuous.min\n        Â· exact continuous_id\n        Â· exact continuous_const\n    Â· constructor\n      Â· -- Prove that for all x, r x âˆˆ Set.Icc 0 1\n        intro x\n        constructor\n        Â· -- Prove 0 â‰¤ r x\n          have hâ‚ : (0 : â„) â‰¤ max 0 (min x 1) := by\n            apply le_max_left\n          exact hâ‚\n        Â· -- Prove r x â‰¤ 1\n          have hâ‚‚ : max 0 (min x 1) â‰¤ 1 := by\n            have hâ‚ƒ : min x 1 â‰¤ 1 := by\n              apply min_le_right\n            have hâ‚„ : (0 : â„) â‰¤ 1 := by norm_num\n            have hâ‚… : max 0 (min x 1) â‰¤ 1 := by\n              apply max_le\n              Â· linarith\n              Â· linarith\n            exact hâ‚…\n          exact hâ‚‚\n      Â· -- Prove that for all x âˆˆ Set.Icc 0 1, r x = x\n        intro x hx\n        have hâ‚ : 0 â‰¤ x := hx.1\n        have hâ‚‚ : x â‰¤ 1 := hx.2\n        have hâ‚ƒ : min x 1 = x := by\n          rw [min_eq_left]\n          <;> linarith\n        have hâ‚„ : max 0 (min x 1) = x := by\n          rw [hâ‚ƒ]\n          rw [max_eq_right]\n          <;> linarith\n        rw [hâ‚„]\n  exact h_main"}
{"id": "c1887", "nl_problem": "Prove that a set 's' is a facet of a polyhedron 'K' if and only if 's' is a face of 'K' and no other face of 'K' contains 's' as a proper subset.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem facet_maximal_face_equivalence {ğ•œ : Type*} [Ring ğ•œ] [PartialOrder ğ•œ] {E : Type*} [AddCommGroup E] [Module ğ•œ E]\n  (K : Geometry.SimplicialComplex ğ•œ E) (s : Finset E) :\n  s âˆˆ Geometry.SimplicialComplex.facets K â†” (s âˆˆ K.faces âˆ§ âˆ€ F âˆˆ K.faces, s âŠ† F â†’ s = F) :=", "formal_code": "import Mathlib\ntheorem facet_maximal_face_equivalence {ğ•œ : Type*} [Ring ğ•œ] [PartialOrder ğ•œ] {E : Type*} [AddCommGroup E] [Module ğ•œ E]\n  (K : Geometry.SimplicialComplex ğ•œ E) (s : Finset E) :\n  s âˆˆ Geometry.SimplicialComplex.facets K â†” (s âˆˆ K.faces âˆ§ âˆ€ F âˆˆ K.faces, s âŠ† F â†’ s = F) := by\n  exact Geometry.SimplicialComplex.mem_facets"}
{"id": "c241", "nl_problem": "What is the value of $a+b+c+d+e+f$ for the decimal representation of $\\frac{4}{37}+\\frac{3}{11}+\\frac{23}{9}=2.abcdef\\ldots$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem compute_decimal_sum_digits : \n  let sum := (4 : â„š) / 37 + (3 : â„š) / 11 + (23 : â„š) / 9\n  let fractional_part := sum - âŒŠsumâŒ‹\n  let digit1 := âŒŠfractional_part * 10âŒ‹ % 10\n  let digit2 := âŒŠfractional_part * 100âŒ‹ % 10\n  let digit3 := âŒŠfractional_part * 1000âŒ‹ % 10\n  let digit4 := âŒŠfractional_part * 10000âŒ‹ % 10\n  let digit5 := âŒŠfractional_part * 100000âŒ‹ % 10\n  let digit6 := âŒŠfractional_part * 1000000âŒ‹ % 10\n  digit1 + digit2 + digit3 + digit4 + digit5 + digit6 = 30 :=", "formal_code": "import Mathlib\ntheorem compute_decimal_sum_digits : \n  let sum := (4 : â„š) / 37 + (3 : â„š) / 11 + (23 : â„š) / 9\n  let fractional_part := sum - âŒŠsumâŒ‹\n  let digit1 := âŒŠfractional_part * 10âŒ‹ % 10\n  let digit2 := âŒŠfractional_part * 100âŒ‹ % 10\n  let digit3 := âŒŠfractional_part * 1000âŒ‹ % 10\n  let digit4 := âŒŠfractional_part * 10000âŒ‹ % 10\n  let digit5 := âŒŠfractional_part * 100000âŒ‹ % 10\n  let digit6 := âŒŠfractional_part * 1000000âŒ‹ % 10\n  digit1 + digit2 + digit3 + digit4 + digit5 + digit6 = 30 := by\n  norm_num"}
{"id": "c1733", "nl_problem": "Prove that a list `l` is equal to the sublist obtained by taking elements from the beginning of `l` as long as they satisfy a predicate `p`, if and only if all elements in `l` satisfy `p`.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem list_takewhile_all_satisfy (Î± : Type*) (l : List Î±) (p : Î± â†’ Bool) : \n  l = List.takeWhile p l â†” List.all l p :=", "formal_code": "import Mathlib\ntheorem list_takewhile_all_satisfy (Î± : Type*) (l : List Î±) (p : Î± â†’ Bool) : \n  l = List.takeWhile p l â†” List.all l p := by\n  simp only [List.all_eq_true]\n  constructor\n  Â· intro h\n    exact List.takeWhile_eq_self_iff.mp h.symm\n  Â· intro h\n    exact (List.takeWhile_eq_self_iff.mpr h).symm"}
