{"id": "c1297", "nl_problem": "Prove that $n^2-1$ is divisible by $8$ if $n$ is an odd positive integer using the identity $n=2m+1$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem prove_odd_square_minus_one_divisible_by_eight : ∀ n : ℤ, 0 < n → Odd n → 8 ∣ (n^2 - 1) :=", "formal_code": "import Mathlib\ntheorem prove_odd_square_minus_one_divisible_by_eight : ∀ n : ℤ, 0 < n → Odd n → 8 ∣ (n^2 - 1) := by\n  intro n hn hodd\n  have h_main : n^2 % 8 = 1 := by\n    have h₁ : n % 8 = 1 ∨ n % 8 = 3 ∨ n % 8 = 5 ∨ n % 8 = 7 := by\n      have h₂ : n % 2 = 1 := by\n        cases' hodd with k hk\n        have : n % 2 = 1 := by\n          omega\n        exact this\n      have h₃ : n % 8 = 1 ∨ n % 8 = 3 ∨ n % 8 = 5 ∨ n % 8 = 7 := by\n        have : n % 8 = 1 ∨ n % 8 = 3 ∨ n % 8 = 5 ∨ n % 8 = 7 := by\n          omega\n        exact this\n      exact h₃\n    have h₂ : n^2 % 8 = 1 := by\n      rcases h₁ with (h₁ | h₁ | h₁ | h₁)\n      · -- Case: n ≡ 1 mod 8\n        have h₃ : n % 8 = 1 := h₁\n        have h₄ : n^2 % 8 = 1 := by\n          have : n % 8 = 1 := h₃\n          have : n^2 % 8 = 1 := by\n            norm_num [pow_two, Int.mul_emod, this]\n          exact this\n        exact h₄\n      · -- Case: n ≡ 3 mod 8\n        have h₃ : n % 8 = 3 := h₁\n        have h₄ : n^2 % 8 = 1 := by\n          have : n % 8 = 3 := h₃\n          have : n^2 % 8 = 1 := by\n            norm_num [pow_two, Int.mul_emod, this]\n          exact this\n        exact h₄\n      · -- Case: n ≡ 5 mod 8\n        have h₃ : n % 8 = 5 := h₁\n        have h₄ : n^2 % 8 = 1 := by\n          have : n % 8 = 5 := h₃\n          have : n^2 % 8 = 1 := by\n            norm_num [pow_two, Int.mul_emod, this]\n          exact this\n        exact h₄\n      · -- Case: n ≡ 7 mod 8\n        have h₃ : n % 8 = 7 := h₁\n        have h₄ : n^2 % 8 = 1 := by\n          have : n % 8 = 7 := h₃\n          have : n^2 % 8 = 1 := by\n            norm_num [pow_two, Int.mul_emod, this]\n          exact this\n        exact h₄\n    exact h₂\n  \n  have h_final : 8 ∣ (n^2 - 1) := by\n    have h₁ : (n^2 - 1 : ℤ) % 8 = 0 := by\n      have h₂ : (n^2 : ℤ) % 8 = 1 := by exact_mod_cast h_main\n      have h₃ : (n^2 - 1 : ℤ) % 8 = 0 := by\n        omega\n      exact h₃\n    -- Use the fact that if a number modulo 8 is 0, then 8 divides that number.\n    have h₂ : 8 ∣ (n^2 - 1 : ℤ) := by\n      omega\n    exact h₂\n  \n  exact h_final"}
{"id": "c1262", "nl_problem": "Show that the $n$ th triangular number is given by the formula\\n\\n$T_{n}=\\frac{1}{2}n(n+1)$", "formal_type": "Lean", "header": "import Mathlib\ntheorem triangular_number_formula_h1 (n : ℕ) : (∑ k in Finset.Icc 1 n, k : ℕ) = ∑ i in Finset.range (n + 1), i := by\n  have h : Finset.range (n + 1) = insert 0 (Finset.Icc 1 n) := by\n    ext i\n    simp [Finset.mem_range, Finset.mem_Icc, Finset.mem_insert]\n    omega\n  rw [h]\n  have h_not_mem : 0 ∉ Finset.Icc 1 n := by\n    simp [Finset.mem_Icc]\n  simp [Finset.sum_insert h_not_mem]\ntheorem triangular_number_formula_h2 (n : ℕ) : (∑ i in Finset.range (n + 1), i : ℕ) = (n + 1) * n / 2 := by\n  rw [Finset.sum_range_id]\n  simp only [Nat.add_sub_cancel]\ntheorem triangular_number_formula_h3 (n : ℕ) : ((n + 1) * n / 2 : ℕ) = (n * (n + 1) / 2 : ℕ) := by\n  rw [Nat.mul_comm (n + 1) n]\ntheorem triangular_number_formula_h4 (n : ℕ) (h1 : (∑ k in Finset.Icc 1 n, k : ℕ) = ∑ i in Finset.range (n + 1), i) (h2 : (∑ i in Finset.range (n + 1), i : ℕ) = (n + 1) * n / 2) (h3 : ((n + 1) * n / 2 : ℕ) = (n * (n + 1) / 2 : ℕ)) : ((∑ k in Finset.Icc 1 n, k : ℕ) : ℚ) = (n * (n + 1) / 2 : ℕ) := by\n  have eq : (∑ k in Finset.Icc 1 n, k : ℕ) = (n * (n + 1) / 2 : ℕ) := by\n    rw [h1, h2, h3]\n  exact_mod_cast eq\ntheorem triangular_number_formula_h5 (n : ℕ) : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n  have h_even : 2 ∣ n * (n + 1) := by\n    have h : n % 2 = 0 ∨ (n + 1) % 2 = 0 := by\n      have : n % 2 = 0 ∨ n % 2 = 1 := by omega\n      rcases this with (h | h)\n      · exact Or.inl h\n      · have h₁ : (n + 1) % 2 = 0 := by\n          omega\n        exact Or.inr h₁\n    rcases h with (h | h)\n    · -- Case: n is even\n      have h₁ : 2 ∣ n := by\n        omega\n      have h₂ : 2 ∣ n * (n + 1) := by\n        exact dvd_mul_of_dvd_left h₁ (n + 1)\n      exact h₂\n    · -- Case: n + 1 is even\n      have h₁ : 2 ∣ (n + 1) := by\n        omega\n      have h₂ : 2 ∣ n * (n + 1) := by\n        exact dvd_mul_of_dvd_right h₁ n\n      exact h₂\n  \n  have h_div_mul : (n * (n + 1) / 2 : ℕ) * 2 = n * (n + 1) := by\n    have h₁ : 2 ∣ n * (n + 1) := h_even\n    have h₂ : (n * (n + 1) / 2 : ℕ) * 2 = n * (n + 1) := by\n      have h₃ : n * (n + 1) / 2 * 2 = n * (n + 1) := by\n        have h₄ : 2 ∣ n * (n + 1) := h₁\n        have h₅ : n * (n + 1) / 2 * 2 = n * (n + 1) := by\n          apply Nat.div_mul_cancel h₄\n        exact h₅\n      simpa [mul_comm, mul_assoc, mul_left_comm] using h₃\n    exact h₂\n  \n  have h_cast_div_mul : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = (n * (n + 1) : ℚ) := by\n    have h₁ : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = ((n * (n + 1) / 2 : ℕ) * 2 : ℚ) := by\n      norm_cast\n      <;> ring_nf\n      <;> field_simp\n      <;> norm_cast\n    rw [h₁]\n    have h₂ : ((n * (n + 1) / 2 : ℕ) * 2 : ℚ) = (n * (n + 1) : ℚ) := by\n      norm_cast at h_div_mul ⊢\n      <;>\n      (try norm_num) <;>\n      (try ring_nf at h_div_mul ⊢) <;>\n      (try simp_all [Nat.cast_mul, Nat.cast_add, Nat.cast_one]) <;>\n      (try norm_num) <;>\n      (try linarith)\n      <;>\n      (try omega)\n    rw [h₂]\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try simp_all [Nat.cast_mul, Nat.cast_add, Nat.cast_one]) <;>\n    (try norm_num) <;>\n    (try linarith)\n    <;>\n    (try omega)\n  \n  have h_main : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n    have h₁ : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = (n * (n + 1) : ℚ) := h_cast_div_mul\n    have h₂ : (n : ℚ) * (n + 1) / 2 * 2 = (n : ℚ) * (n + 1) := by\n      ring_nf\n      <;> field_simp\n      <;> ring_nf\n    have h₃ : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n      apply mul_left_cancel₀ (show (2 : ℚ) ≠ 0 by norm_num)\n      have h₄ : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = (n : ℚ) * (n + 1) := by\n        have h₅ : (n * (n + 1) : ℚ) = (n : ℚ) * (n + 1) := by\n          norm_cast\n          <;> ring_nf\n        linarith\n      have h₅ : (n : ℚ) * (n + 1) / 2 * 2 = (n : ℚ) * (n + 1) := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n      nlinarith\n    exact h₃\n  \n  apply h_main\n", "formal_statement": "theorem triangular_number_formula (n : ℕ) : (∑ k in Finset.Icc 1 n, k : ℚ) = n * (n + 1) / 2 :=", "formal_code": "import Mathlib\ntheorem triangular_number_formula_h1 (n : ℕ) : (∑ k in Finset.Icc 1 n, k : ℕ) = ∑ i in Finset.range (n + 1), i := by\n  have h : Finset.range (n + 1) = insert 0 (Finset.Icc 1 n) := by\n    ext i\n    simp [Finset.mem_range, Finset.mem_Icc, Finset.mem_insert]\n    omega\n  rw [h]\n  have h_not_mem : 0 ∉ Finset.Icc 1 n := by\n    simp [Finset.mem_Icc]\n  simp [Finset.sum_insert h_not_mem]\ntheorem triangular_number_formula_h2 (n : ℕ) : (∑ i in Finset.range (n + 1), i : ℕ) = (n + 1) * n / 2 := by\n  rw [Finset.sum_range_id]\n  simp only [Nat.add_sub_cancel]\ntheorem triangular_number_formula_h3 (n : ℕ) : ((n + 1) * n / 2 : ℕ) = (n * (n + 1) / 2 : ℕ) := by\n  rw [Nat.mul_comm (n + 1) n]\ntheorem triangular_number_formula_h4 (n : ℕ) (h1 : (∑ k in Finset.Icc 1 n, k : ℕ) = ∑ i in Finset.range (n + 1), i) (h2 : (∑ i in Finset.range (n + 1), i : ℕ) = (n + 1) * n / 2) (h3 : ((n + 1) * n / 2 : ℕ) = (n * (n + 1) / 2 : ℕ)) : ((∑ k in Finset.Icc 1 n, k : ℕ) : ℚ) = (n * (n + 1) / 2 : ℕ) := by\n  have eq : (∑ k in Finset.Icc 1 n, k : ℕ) = (n * (n + 1) / 2 : ℕ) := by\n    rw [h1, h2, h3]\n  exact_mod_cast eq\ntheorem triangular_number_formula_h5 (n : ℕ) : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n  have h_even : 2 ∣ n * (n + 1) := by\n    have h : n % 2 = 0 ∨ (n + 1) % 2 = 0 := by\n      have : n % 2 = 0 ∨ n % 2 = 1 := by omega\n      rcases this with (h | h)\n      · exact Or.inl h\n      · have h₁ : (n + 1) % 2 = 0 := by\n          omega\n        exact Or.inr h₁\n    rcases h with (h | h)\n    · -- Case: n is even\n      have h₁ : 2 ∣ n := by\n        omega\n      have h₂ : 2 ∣ n * (n + 1) := by\n        exact dvd_mul_of_dvd_left h₁ (n + 1)\n      exact h₂\n    · -- Case: n + 1 is even\n      have h₁ : 2 ∣ (n + 1) := by\n        omega\n      have h₂ : 2 ∣ n * (n + 1) := by\n        exact dvd_mul_of_dvd_right h₁ n\n      exact h₂\n  \n  have h_div_mul : (n * (n + 1) / 2 : ℕ) * 2 = n * (n + 1) := by\n    have h₁ : 2 ∣ n * (n + 1) := h_even\n    have h₂ : (n * (n + 1) / 2 : ℕ) * 2 = n * (n + 1) := by\n      have h₃ : n * (n + 1) / 2 * 2 = n * (n + 1) := by\n        have h₄ : 2 ∣ n * (n + 1) := h₁\n        have h₅ : n * (n + 1) / 2 * 2 = n * (n + 1) := by\n          apply Nat.div_mul_cancel h₄\n        exact h₅\n      simpa [mul_comm, mul_assoc, mul_left_comm] using h₃\n    exact h₂\n  \n  have h_cast_div_mul : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = (n * (n + 1) : ℚ) := by\n    have h₁ : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = ((n * (n + 1) / 2 : ℕ) * 2 : ℚ) := by\n      norm_cast\n      <;> ring_nf\n      <;> field_simp\n      <;> norm_cast\n    rw [h₁]\n    have h₂ : ((n * (n + 1) / 2 : ℕ) * 2 : ℚ) = (n * (n + 1) : ℚ) := by\n      norm_cast at h_div_mul ⊢\n      <;>\n      (try norm_num) <;>\n      (try ring_nf at h_div_mul ⊢) <;>\n      (try simp_all [Nat.cast_mul, Nat.cast_add, Nat.cast_one]) <;>\n      (try norm_num) <;>\n      (try linarith)\n      <;>\n      (try omega)\n    rw [h₂]\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try simp_all [Nat.cast_mul, Nat.cast_add, Nat.cast_one]) <;>\n    (try norm_num) <;>\n    (try linarith)\n    <;>\n    (try omega)\n  \n  have h_main : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n    have h₁ : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = (n * (n + 1) : ℚ) := h_cast_div_mul\n    have h₂ : (n : ℚ) * (n + 1) / 2 * 2 = (n : ℚ) * (n + 1) := by\n      ring_nf\n      <;> field_simp\n      <;> ring_nf\n    have h₃ : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n      apply mul_left_cancel₀ (show (2 : ℚ) ≠ 0 by norm_num)\n      have h₄ : ((n * (n + 1) / 2 : ℕ) : ℚ) * 2 = (n : ℚ) * (n + 1) := by\n        have h₅ : (n * (n + 1) : ℚ) = (n : ℚ) * (n + 1) := by\n          norm_cast\n          <;> ring_nf\n        linarith\n      have h₅ : (n : ℚ) * (n + 1) / 2 * 2 = (n : ℚ) * (n + 1) := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n      nlinarith\n    exact h₃\n  \n  apply h_main\ntheorem triangular_number_formula (n : ℕ) : (∑ k in Finset.Icc 1 n, k : ℚ) = n * (n + 1) / 2 := by\n  have h1 : (∑ k in Finset.Icc 1 n, k : ℕ) = ∑ i in Finset.range (n + 1), i := by\n    exact triangular_number_formula_h1 n\n  have h2 : (∑ i in Finset.range (n + 1), i : ℕ) = (n + 1) * n / 2 := by\n    exact triangular_number_formula_h2 n\n  have h3 : ((n + 1) * n / 2 : ℕ) = (n * (n + 1) / 2 : ℕ) := by\n    exact triangular_number_formula_h3 n\n  have h4 : ((∑ k in Finset.Icc 1 n, k : ℕ) : ℚ) = (n * (n + 1) / 2 : ℕ) := by\n    exact triangular_number_formula_h4 n h1 h2 h3\n  have h5 : ((n * (n + 1) / 2 : ℕ) : ℚ) = (n : ℚ) * (n + 1) / 2 := by\n    exact triangular_number_formula_h5 n\n  rw [← h5]\n  exact h4"}
{"id": "c1360", "nl_problem": "Prove that if $x^2 + y^2 = 1$ and $x, y$ are real numbers, then $x + y \\leq \\sqrt{2}$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem maximize_sum_under_circle_constraint : ∀ x y : ℝ, x^2 + y^2 = 1 → x + y ≤ Real.sqrt 2 :=", "formal_code": "import Mathlib\ntheorem maximize_sum_under_circle_constraint : ∀ x y : ℝ, x^2 + y^2 = 1 → x + y ≤ Real.sqrt 2 := by\n  intro x y h\n  have h1 : (x + y)^2 + (x - y)^2 = 2 * (x^2 + y^2) := by\n    ring_nf\n    <;>\n    linarith [sq_nonneg (x + y), sq_nonneg (x - y)]\n  \n  have h2 : (x - y)^2 ≥ 0 := by\n    nlinarith [sq_nonneg (x - y)]\n  \n  have h3 : (x + y)^2 ≤ 2 := by\n    have h4 : (x + y)^2 + (x - y)^2 = 2 * (x^2 + y^2) := h1\n    have h5 : (x - y)^2 ≥ 0 := h2\n    have h6 : x^2 + y^2 = 1 := h\n    have h7 : (x + y)^2 + (x - y)^2 = 2 := by\n      calc\n        (x + y)^2 + (x - y)^2 = 2 * (x^2 + y^2) := h4\n        _ = 2 * 1 := by rw [h6]\n        _ = 2 := by ring\n    nlinarith\n  \n  have h4 : x + y ≤ Real.sqrt 2 := by\n    have h5 : (x + y) ^ 2 ≤ 2 := h3\n    have h6 : x + y ≤ Real.sqrt 2 := by\n      apply Real.le_sqrt_of_sq_le\n      linarith\n    exact h6\n  \n  exact h4"}
{"id": "c1310", "nl_problem": "prove that : $ 2w^2 + 9 \\ge 6\\sqrt {2}w$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem inequality_with_square_root : ∀ w : ℝ, 2 * w^2 + 9 ≥ 6 * Real.sqrt 2 * w :=", "formal_code": "import Mathlib\ntheorem inequality_with_square_root : ∀ w : ℝ, 2 * w^2 + 9 ≥ 6 * Real.sqrt 2 * w := by\n  intro w\n  have sqrt_2_sq : Real.sqrt 2 ^ 2 = 2 := by norm_num\n  have sqrt_2_pos : 0 < Real.sqrt 2 := by norm_num\n  have key : 2 * w^2 + 9 - 6 * Real.sqrt 2 * w = 2 * (w - (3 * Real.sqrt 2) / 2)^2 := by\n    have h : (3 * Real.sqrt 2 / 2) ^ 2 = 9 / 2 := by nlinarith [sqrt_2_sq]\n    nlinarith [sqrt_2_sq, h]\n  have sq_nonneg : 0 ≤ (w - (3 * Real.sqrt 2) / 2)^2 := sq_nonneg _\n  linarith [key, sq_nonneg]"}
{"id": "c1082", "nl_problem": "Prove that $ab \\leq \\frac{1}{4}$ given $a + b = 1$ and $a, b \\geq 0$.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem maximize_product_under_constraint (a b : ℝ) (h1 : a + b = 1) (h2 : 0 ≤ a) (h3 : 0 ≤ b) : a * b ≤ 1/4 :=", "formal_code": "import Mathlib\ntheorem maximize_product_under_constraint (a b : ℝ) (h1 : a + b = 1) (h2 : 0 ≤ a) (h3 : 0 ≤ b) : a * b ≤ 1/4 := by\n  have h4 : (a - b)^2 ≥ 0 := by\n    -- The square of any real number is non-negative.\n    nlinarith [sq_nonneg (a - b)]\n  \n  have h5 : (a + b)^2 ≥ 4 * (a * b) := by\n    -- Expand (a - b)^2 and rearrange to get (a + b)^2 ≥ 4ab\n    have h5₁ : (a - b)^2 ≥ 0 := h4\n    have h5₂ : a^2 - 2 * a * b + b^2 ≥ 0 := by\n      nlinarith\n    have h5₃ : a^2 + 2 * a * b + b^2 ≥ 4 * a * b := by\n      nlinarith\n    have h5₄ : (a + b)^2 ≥ 4 * (a * b) := by\n      calc\n        (a + b)^2 = a^2 + 2 * a * b + b^2 := by ring\n        _ ≥ 4 * a * b := by nlinarith\n        _ = 4 * (a * b) := by ring\n    exact h5₄\n  \n  have h6 : 1 ≥ 4 * (a * b) := by\n    have h6₁ : (a + b)^2 ≥ 4 * (a * b) := h5\n    have h6₂ : (a + b)^2 = 1 := by\n      rw [h1]\n      <;> norm_num\n    have h6₃ : 1 ≥ 4 * (a * b) := by\n      linarith\n    exact h6₃\n  \n  have h7 : a * b ≤ 1/4 := by\n    have h7₁ : 1 ≥ 4 * (a * b) := h6\n    have h7₂ : a * b ≤ 1 / 4 := by\n      -- Divide both sides by 4 to get the final inequality\n      linarith\n    exact h7₂\n  \n  exact h7"}
{"id": "c1430", "nl_problem": "Prove $x+\\frac{1}{x+1} \\geq \\frac{3}{4}(x+1)$ for all positive real numbers $x$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem inequality_for_positive_reals (x : ℝ) (hx : 0 < x) : x + 1 / (x + 1) ≥ (3 / 4) * (x + 1) :=", "formal_code": "import Mathlib\ntheorem inequality_for_positive_reals (x : ℝ) (hx : 0 < x) : x + 1 / (x + 1) ≥ (3 / 4) * (x + 1) := by\n  have h1 : 0 < x + 1 := by linarith\n  have h2 : x + 1 ≠ 0 := by linarith\n  have h3 : 0 < 4 * (x + 1) := by linarith\n  \n  -- Start from (x - 1)^2 ≥ 0\n  have key : (x - 1) ^ 2 ≥ 0 := sq_nonneg (x - 1)\n  \n  -- Expand to x^2 - 2x + 1 ≥ 0\n  have expanded : x ^ 2 - 2 * x + 1 ≥ 0 := by nlinarith [key]\n  \n  -- Add 3x^2 + 6x + 3 to both sides\n  have added : x ^ 2 - 2 * x + 1 + (3 * x ^ 2 + 6 * x + 3) ≥ 0 + (3 * x ^ 2 + 6 * x + 3) := by\n    linarith [expanded]\n  \n  -- Simplify: 4x^2 + 4x + 4 ≥ 3x^2 + 6x + 3\n  have simplified : 4 * x ^ 2 + 4 * x + 4 ≥ 3 * x ^ 2 + 6 * x + 3 := by nlinarith [added]\n  \n  -- Factor: 4(x(x+1) + 1) ≥ 3(x+1)^2\n  have factored : 4 * (x * (x + 1) + 1) ≥ 3 * (x + 1) ^ 2 := by nlinarith [simplified]\n  \n  -- Divide both sides by 4(x+1) using div_le_div_right\n  have divided : (4 * (x * (x + 1) + 1)) / (4 * (x + 1)) ≥ (3 * (x + 1) ^ 2) / (4 * (x + 1)) := by\n    exact div_le_div_right h3 |>.mpr factored\n  \n  -- Simplify left side: 4(x(x+1) + 1) / (4(x+1)) = (x(x+1) + 1) / (x+1) = x + 1/(x+1)\n  have left_simp : (4 * (x * (x + 1) + 1)) / (4 * (x + 1)) = x + 1 / (x + 1) := by\n    field_simp\n    ring\n  \n  -- Simplify right side: 3(x+1)^2 / (4(x+1)) = 3(x+1) / 4\n  have right_simp : (3 * (x + 1) ^ 2) / (4 * (x + 1)) = (3 / 4) * (x + 1) := by\n    field_simp\n    ring\n  \n  rw [left_simp, right_simp] at divided\n  exact divided"}
{"id": "c1039", "nl_problem": "Prove that $24a^2+6c^2 \\ge 24ac$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem inequality_proof_24a2_6c2_ge_24ac : ∀ a c : ℝ, 24 * a^2 + 6 * c^2 ≥ 24 * a * c :=", "formal_code": "import Mathlib\ntheorem inequality_proof_24a2_6c2_ge_24ac : ∀ a c : ℝ, 24 * a^2 + 6 * c^2 ≥ 24 * a * c := by\n  intro a c\n  have h : 24 * a^2 + 6 * c^2 - 24 * a * c = 6 * (2 * a - c)^2 := by ring\n  have sq_nonneg : (2 * a - c)^2 ≥ 0 := sq_nonneg (2 * a - c)\n  have prod_nonneg : 6 * (2 * a - c)^2 ≥ 0 := mul_nonneg (by norm_num : (6 : ℝ) ≥ 0) sq_nonneg\n  linarith"}
{"id": "c1169", "nl_problem": "Prove $2a^{2}+2b^{2}+2c^{2}\\geq2ab+2bc+2ac$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem inequality_of_squares : ∀ a b c : ℝ, 2 * a^2 + 2 * b^2 + 2 * c^2 ≥ 2 * a * b + 2 * b * c + 2 * a * c :=", "formal_code": "import Mathlib\ntheorem inequality_of_squares : ∀ a b c : ℝ, 2 * a^2 + 2 * b^2 + 2 * c^2 ≥ 2 * a * b + 2 * b * c + 2 * a * c := by\n  intro a b c\n  have h : (a - b)^2 + (b - c)^2 + (c - a)^2 ≥ 0 := by\n    apply add_nonneg\n    apply add_nonneg\n    · exact sq_nonneg (a - b)\n    · exact sq_nonneg (b - c)\n    · exact sq_nonneg (c - a)\n  nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a)]"}
{"id": "c1178", "nl_problem": "Prove that $ |\\sin x + \\cos x| \\leq \\sqrt 2 $", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem sin_cos_abs_bound : ∀ x : ℝ, |Real.sin x + Real.cos x| ≤ Real.sqrt 2 :=", "formal_code": "import Mathlib\ntheorem sin_cos_abs_bound : ∀ x : ℝ, |Real.sin x + Real.cos x| ≤ Real.sqrt 2 := by\n  intro x\n  -- We'll prove this by showing (sin x + cos x)² ≤ 2, then taking square roots\n  have h1 : (Real.sin x + Real.cos x) ^ 2 ≤ 2 := by\n    -- Expand (sin x + cos x)²\n    have expand : (Real.sin x + Real.cos x) ^ 2 = \n      (Real.sin x) ^ 2 + 2 * Real.sin x * Real.cos x + (Real.cos x) ^ 2 := by ring\n    rw [expand]\n    -- Rearrange to group sin² and cos²\n    have rearrange : (Real.sin x) ^ 2 + 2 * Real.sin x * Real.cos x + (Real.cos x) ^ 2 =\n      ((Real.sin x) ^ 2 + (Real.cos x) ^ 2) + 2 * Real.sin x * Real.cos x := by ring\n    rw [rearrange]\n    -- Apply Pythagorean identity\n    rw [Real.sin_sq_add_cos_sq]\n    -- Now we have 1 + 2 * sin x * cos x ≤ 2\n    -- Use that 2 * sin x * cos x = sin(2x)\n    have double_angle : 2 * Real.sin x * Real.cos x = Real.sin (2 * x) := by\n      have h := Real.two_mul_sin_mul_cos x x\n      -- h : 2 * sin x * cos x = sin(x - x) + sin(x + x)\n      have sin_zero : Real.sin 0 = 0 := Real.sin_zero\n      have sum_eq : x + x = 2 * x := by ring\n      have diff_eq : x - x = 0 := by ring\n      simp only [sin_zero, diff_eq, sum_eq, zero_add] at h\n      exact h\n    rw [double_angle]\n    -- sin(2x) ≤ 1\n    have sin_bound : Real.sin (2 * x) ≤ 1 := Real.sin_le_one (2 * x)\n    linarith\n  -- Now take square roots\n  have h2 : Real.sqrt ((Real.sin x + Real.cos x) ^ 2) ≤ Real.sqrt 2 := by\n    exact Real.sqrt_le_sqrt h1\n  -- sqrt(a²) = |a|\n  have h3 : Real.sqrt ((Real.sin x + Real.cos x) ^ 2) = |Real.sin x + Real.cos x| := by\n    exact Real.sqrt_sq_eq_abs (Real.sin x + Real.cos x)\n  rw [h3] at h2\n  exact h2"}
{"id": "c1436", "nl_problem": "Prove that if $x>0$, then $g(x)=x+\\frac{1}{x}\\geq 2$ with equality if and only if $x=1$.", "formal_type": "Lean", "header": "import Mathlib\ntheorem inequality_positive_real_sum_reciprocal_w₁_nonneg : 0 ≤ (1 : ℝ) / 2 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_w₂_nonneg : 0 ≤ (1 : ℝ) / 2 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_p₁_nonneg (x : ℝ) (hx : 0 < x) : 0 ≤ x := by\n  exact le_of_lt hx\ntheorem inequality_positive_real_sum_reciprocal_p₂_nonneg (x : ℝ) (hx : 0 < x) : 0 ≤ 1 / x := by\n  have h : 0 < 1 / x := one_div_pos.mpr hx\n  exact le_of_lt h\ntheorem inequality_positive_real_sum_reciprocal_weights_sum : (1 : ℝ) / 2 + 1 / 2 = 1 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_am_gm_applied (x : ℝ) (hx : 0 < x) (w₁_nonneg : 0 ≤ (1 : ℝ) / 2) (w₂_nonneg : 0 ≤ (1 : ℝ) / 2) (p₁_nonneg : 0 ≤ x) (p₂_nonneg : 0 ≤ 1 / x) (weights_sum : (1 : ℝ) / 2 + 1 / 2 = 1) : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) ≤ (1 / 2) * x + (1 / 2) * (1 / x) := by\n  exact Real.geom_mean_le_arith_mean2_weighted w₁_nonneg w₂_nonneg p₁_nonneg p₂_nonneg weights_sum\ntheorem inequality_positive_real_sum_reciprocal_lhs_simplify (x : ℝ) (hx : 0 < x) : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1 := by\n  have h₁ : 0 ≤ x := by\n    linarith\n  \n  have h₂ : 0 ≤ (1 / x : ℝ) := by\n    have h₂₁ : 0 < x := hx\n    have h₂₂ : 0 < (1 / x : ℝ) := by positivity\n    linarith\n  \n  have h₃ : (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) = 1 := by\n    have h₃₁ : x * (1 / x : ℝ) = 1 := by\n      field_simp [hx.ne']\n      <;> ring_nf\n      <;> linarith\n    rw [h₃₁]\n    -- Now we need to show that 1 ^ (1 / 2 : ℝ) = 1\n    have h₃₂ : (1 : ℝ) ^ (1 / 2 : ℝ) = 1 := by\n      -- Use the property that 1 raised to any real power is 1\n      norm_num [Real.one_rpow]\n    rw [h₃₂]\n  \n  have h₄ : (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x : ℝ) ^ (1 / 2 : ℝ) := by\n    have h₄₁ : 0 ≤ x := h₁\n    have h₄₂ : 0 ≤ (1 / x : ℝ) := h₂\n    -- Use the property of exponents: (x * y)^a = x^a * y^a\n    have h₄₃ : (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x : ℝ) ^ (1 / 2 : ℝ) := by\n      rw [Real.mul_rpow (by positivity) (by positivity)]\n      <;> ring_nf\n    rw [h₄₃]\n  \n  have h₅ : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1 := by\n    calc\n      x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x : ℝ) ^ (1 / 2 : ℝ) := by norm_num\n      _ = (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) := by\n        rw [h₄]\n        <;> ring_nf\n      _ = 1 := by rw [h₃]\n  \n  exact h₅\ntheorem inequality_positive_real_sum_reciprocal_rhs_factor (x : ℝ) (hx : 0 < x) : (1 / 2) * x + (1 / 2) * (1 / x) = (1 / 2) * (x + 1 / x) := by\n  ring\ntheorem inequality_positive_real_sum_reciprocal_inequality_after_simplify (x : ℝ) (hx : 0 < x) (am_gm_applied : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) ≤ (1 / 2) * x + (1 / 2) * (1 / x)) (lhs_simplify : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1) (rhs_factor : (1 / 2) * x + (1 / 2) * (1 / x) = (1 / 2) * (x + 1 / x)) : (1 : ℝ) ≤ (1 / 2) * (x + 1 / x) := by\n  calc (1 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) := lhs_simplify.symm\n    _ ≤ (1 / 2) * x + (1 / 2) * (1 / x) := am_gm_applied\n    _ = (1 / 2) * (x + 1 / x) := rhs_factor\ntheorem inequality_positive_real_sum_reciprocal_multiply_by_two (x : ℝ) (hx : 0 < x) (inequality_after_simplify : (1 : ℝ) ≤ (1 / 2) * (x + 1 / x)) : (2 : ℝ) ≤ x + 1 / x := by\n  nlinarith [inequality_after_simplify]\ntheorem inequality_positive_real_sum_reciprocal_multiply_by_x (x : ℝ) (hx : 0 < x) (h_eq : x + 1 / x = 2) : x * (x + 1 / x) = x * 2 := by\n  rw [h_eq]\ntheorem inequality_positive_real_sum_reciprocal_expand_lhs (x : ℝ) (hx : 0 < x) (multiply_by_x : x * (x + 1 / x) = x * 2) : x * x + x * (1 / x) = 2 * x := by\n  have h1 : x * (x + 1 / x) = x * x + x * (1 / x) := by ring\n  have h2 : x * 2 = 2 * x := by ring\n  rw [← h1, multiply_by_x, h2]\ntheorem inequality_positive_real_sum_reciprocal_simplify_lhs (x : ℝ) (hx : 0 < x) (expand_lhs : x * x + x * (1 / x) = 2 * x) : x ^ 2 + 1 = 2 * x := by\n  have hx_ne : x ≠ 0 := ne_of_gt hx\n  have h1 : x * (1 / x) = 1 := by field_simp [hx_ne]\n  have h2 : x * x = x ^ 2 := by ring\n  rw [h2, h1] at expand_lhs\n  exact expand_lhs\ntheorem inequality_positive_real_sum_reciprocal_rearrange (x : ℝ) (hx : 0 < x) (simplify_lhs : x ^ 2 + 1 = 2 * x) : x ^ 2 - 2 * x + 1 = 0 := by\n  linarith\ntheorem inequality_positive_real_sum_reciprocal_factor (x : ℝ) (hx : 0 < x) (rearrange : x ^ 2 - 2 * x + 1 = 0) : (x - 1) ^ 2 = 0 := by\n  have h : (x - 1) ^ 2 = x ^ 2 - 2 * x + 1 := by ring\n  rw [h]\n  exact rearrange\ntheorem inequality_positive_real_sum_reciprocal_sqrt_both_sides (x : ℝ) (hx : 0 < x) (factor : (x - 1) ^ 2 = 0) : |x - 1| = 0 := by\n  have h1 : x - 1 = 0 := by\n    have : (x - 1) ^ 2 = 0 := factor\n    exact sq_eq_zero_iff.mp this\n  rw [h1]\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_abs_zero (x : ℝ) (hx : 0 < x) (sqrt_both_sides : |x - 1| = 0) : x - 1 = 0 := by\n  exact abs_eq_zero.mp sqrt_both_sides\ntheorem inequality_positive_real_sum_reciprocal_result (x : ℝ) (hx : 0 < x) (abs_zero : x - 1 = 0) : x = 1 := by\n  linarith\ntheorem inequality_positive_real_sum_reciprocal_substitute : (1 : ℝ) + 1 / 1 = 2 := by\n  norm_num\n", "formal_statement": "theorem inequality_positive_real_sum_reciprocal (x : ℝ) (hx : 0 < x) : \n  (x + 1/x ≥ 2) ∧ (x + 1/x = 2 ↔ x = 1) :=", "formal_code": "import Mathlib\ntheorem inequality_positive_real_sum_reciprocal_w₁_nonneg : 0 ≤ (1 : ℝ) / 2 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_w₂_nonneg : 0 ≤ (1 : ℝ) / 2 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_p₁_nonneg (x : ℝ) (hx : 0 < x) : 0 ≤ x := by\n  exact le_of_lt hx\ntheorem inequality_positive_real_sum_reciprocal_p₂_nonneg (x : ℝ) (hx : 0 < x) : 0 ≤ 1 / x := by\n  have h : 0 < 1 / x := one_div_pos.mpr hx\n  exact le_of_lt h\ntheorem inequality_positive_real_sum_reciprocal_weights_sum : (1 : ℝ) / 2 + 1 / 2 = 1 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_am_gm_applied (x : ℝ) (hx : 0 < x) (w₁_nonneg : 0 ≤ (1 : ℝ) / 2) (w₂_nonneg : 0 ≤ (1 : ℝ) / 2) (p₁_nonneg : 0 ≤ x) (p₂_nonneg : 0 ≤ 1 / x) (weights_sum : (1 : ℝ) / 2 + 1 / 2 = 1) : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) ≤ (1 / 2) * x + (1 / 2) * (1 / x) := by\n  exact Real.geom_mean_le_arith_mean2_weighted w₁_nonneg w₂_nonneg p₁_nonneg p₂_nonneg weights_sum\ntheorem inequality_positive_real_sum_reciprocal_lhs_simplify (x : ℝ) (hx : 0 < x) : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1 := by\n  have h₁ : 0 ≤ x := by\n    linarith\n  \n  have h₂ : 0 ≤ (1 / x : ℝ) := by\n    have h₂₁ : 0 < x := hx\n    have h₂₂ : 0 < (1 / x : ℝ) := by positivity\n    linarith\n  \n  have h₃ : (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) = 1 := by\n    have h₃₁ : x * (1 / x : ℝ) = 1 := by\n      field_simp [hx.ne']\n      <;> ring_nf\n      <;> linarith\n    rw [h₃₁]\n    -- Now we need to show that 1 ^ (1 / 2 : ℝ) = 1\n    have h₃₂ : (1 : ℝ) ^ (1 / 2 : ℝ) = 1 := by\n      -- Use the property that 1 raised to any real power is 1\n      norm_num [Real.one_rpow]\n    rw [h₃₂]\n  \n  have h₄ : (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x : ℝ) ^ (1 / 2 : ℝ) := by\n    have h₄₁ : 0 ≤ x := h₁\n    have h₄₂ : 0 ≤ (1 / x : ℝ) := h₂\n    -- Use the property of exponents: (x * y)^a = x^a * y^a\n    have h₄₃ : (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x : ℝ) ^ (1 / 2 : ℝ) := by\n      rw [Real.mul_rpow (by positivity) (by positivity)]\n      <;> ring_nf\n    rw [h₄₃]\n  \n  have h₅ : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1 := by\n    calc\n      x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x : ℝ) ^ (1 / 2 : ℝ) := by norm_num\n      _ = (x * (1 / x : ℝ)) ^ (1 / 2 : ℝ) := by\n        rw [h₄]\n        <;> ring_nf\n      _ = 1 := by rw [h₃]\n  \n  exact h₅\ntheorem inequality_positive_real_sum_reciprocal_rhs_factor (x : ℝ) (hx : 0 < x) : (1 / 2) * x + (1 / 2) * (1 / x) = (1 / 2) * (x + 1 / x) := by\n  ring\ntheorem inequality_positive_real_sum_reciprocal_inequality_after_simplify (x : ℝ) (hx : 0 < x) (am_gm_applied : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) ≤ (1 / 2) * x + (1 / 2) * (1 / x)) (lhs_simplify : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1) (rhs_factor : (1 / 2) * x + (1 / 2) * (1 / x) = (1 / 2) * (x + 1 / x)) : (1 : ℝ) ≤ (1 / 2) * (x + 1 / x) := by\n  calc (1 : ℝ) = x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) := lhs_simplify.symm\n    _ ≤ (1 / 2) * x + (1 / 2) * (1 / x) := am_gm_applied\n    _ = (1 / 2) * (x + 1 / x) := rhs_factor\ntheorem inequality_positive_real_sum_reciprocal_multiply_by_two (x : ℝ) (hx : 0 < x) (inequality_after_simplify : (1 : ℝ) ≤ (1 / 2) * (x + 1 / x)) : (2 : ℝ) ≤ x + 1 / x := by\n  nlinarith [inequality_after_simplify]\ntheorem inequality_positive_real_sum_reciprocal_multiply_by_x (x : ℝ) (hx : 0 < x) (h_eq : x + 1 / x = 2) : x * (x + 1 / x) = x * 2 := by\n  rw [h_eq]\ntheorem inequality_positive_real_sum_reciprocal_expand_lhs (x : ℝ) (hx : 0 < x) (multiply_by_x : x * (x + 1 / x) = x * 2) : x * x + x * (1 / x) = 2 * x := by\n  have h1 : x * (x + 1 / x) = x * x + x * (1 / x) := by ring\n  have h2 : x * 2 = 2 * x := by ring\n  rw [← h1, multiply_by_x, h2]\ntheorem inequality_positive_real_sum_reciprocal_simplify_lhs (x : ℝ) (hx : 0 < x) (expand_lhs : x * x + x * (1 / x) = 2 * x) : x ^ 2 + 1 = 2 * x := by\n  have hx_ne : x ≠ 0 := ne_of_gt hx\n  have h1 : x * (1 / x) = 1 := by field_simp [hx_ne]\n  have h2 : x * x = x ^ 2 := by ring\n  rw [h2, h1] at expand_lhs\n  exact expand_lhs\ntheorem inequality_positive_real_sum_reciprocal_rearrange (x : ℝ) (hx : 0 < x) (simplify_lhs : x ^ 2 + 1 = 2 * x) : x ^ 2 - 2 * x + 1 = 0 := by\n  linarith\ntheorem inequality_positive_real_sum_reciprocal_factor (x : ℝ) (hx : 0 < x) (rearrange : x ^ 2 - 2 * x + 1 = 0) : (x - 1) ^ 2 = 0 := by\n  have h : (x - 1) ^ 2 = x ^ 2 - 2 * x + 1 := by ring\n  rw [h]\n  exact rearrange\ntheorem inequality_positive_real_sum_reciprocal_sqrt_both_sides (x : ℝ) (hx : 0 < x) (factor : (x - 1) ^ 2 = 0) : |x - 1| = 0 := by\n  have h1 : x - 1 = 0 := by\n    have : (x - 1) ^ 2 = 0 := factor\n    exact sq_eq_zero_iff.mp this\n  rw [h1]\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal_abs_zero (x : ℝ) (hx : 0 < x) (sqrt_both_sides : |x - 1| = 0) : x - 1 = 0 := by\n  exact abs_eq_zero.mp sqrt_both_sides\ntheorem inequality_positive_real_sum_reciprocal_result (x : ℝ) (hx : 0 < x) (abs_zero : x - 1 = 0) : x = 1 := by\n  linarith\ntheorem inequality_positive_real_sum_reciprocal_substitute : (1 : ℝ) + 1 / 1 = 2 := by\n  norm_num\ntheorem inequality_positive_real_sum_reciprocal (x : ℝ) (hx : 0 < x) : \n  (x + 1/x ≥ 2) ∧ (x + 1/x = 2 ↔ x = 1) := by\n  constructor\n  · -- Part 1: Prove x + 1/x ≥ 2\n    have w₁_nonneg : 0 ≤ (1 : ℝ) / 2 := inequality_positive_real_sum_reciprocal_w₁_nonneg\n    have w₂_nonneg : 0 ≤ (1 : ℝ) / 2 := inequality_positive_real_sum_reciprocal_w₂_nonneg\n    have p₁_nonneg : 0 ≤ x := inequality_positive_real_sum_reciprocal_p₁_nonneg x hx\n    have p₂_nonneg : 0 ≤ 1 / x := inequality_positive_real_sum_reciprocal_p₂_nonneg x hx\n    have weights_sum : (1 : ℝ) / 2 + 1 / 2 = 1 := inequality_positive_real_sum_reciprocal_weights_sum\n    have am_gm_applied : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) ≤ (1 / 2) * x + (1 / 2) * (1 / x) := \n      inequality_positive_real_sum_reciprocal_am_gm_applied x hx w₁_nonneg w₂_nonneg p₁_nonneg p₂_nonneg weights_sum\n    have lhs_simplify : x ^ (1 / 2 : ℝ) * (1 / x) ^ (1 / 2 : ℝ) = 1 := \n      inequality_positive_real_sum_reciprocal_lhs_simplify x hx\n    have rhs_factor : (1 / 2) * x + (1 / 2) * (1 / x) = (1 / 2) * (x + 1 / x) := \n      inequality_positive_real_sum_reciprocal_rhs_factor x hx\n    have inequality_after_simplify : (1 : ℝ) ≤ (1 / 2) * (x + 1 / x) := \n      inequality_positive_real_sum_reciprocal_inequality_after_simplify x hx am_gm_applied lhs_simplify rhs_factor\n    have multiply_by_two : (2 : ℝ) ≤ x + 1 / x := \n      inequality_positive_real_sum_reciprocal_multiply_by_two x hx inequality_after_simplify\n    exact multiply_by_two\n  · -- Part 2: Prove x + 1/x = 2 ↔ x = 1\n    constructor\n    · -- Forward direction: x + 1/x = 2 => x = 1\n      intro h_eq\n      have multiply_by_x : x * (x + 1 / x) = x * 2 := \n        inequality_positive_real_sum_reciprocal_multiply_by_x x hx h_eq\n      have expand_lhs : x * x + x * (1 / x) = 2 * x := \n        inequality_positive_real_sum_reciprocal_expand_lhs x hx multiply_by_x\n      have simplify_lhs : x ^ 2 + 1 = 2 * x := \n        inequality_positive_real_sum_reciprocal_simplify_lhs x hx expand_lhs\n      have rearrange : x ^ 2 - 2 * x + 1 = 0 := \n        inequality_positive_real_sum_reciprocal_rearrange x hx simplify_lhs\n      have factor : (x - 1) ^ 2 = 0 := \n        inequality_positive_real_sum_reciprocal_factor x hx rearrange\n      have sqrt_both_sides : |x - 1| = 0 := \n        inequality_positive_real_sum_reciprocal_sqrt_both_sides x hx factor\n      have abs_zero : x - 1 = 0 := \n        inequality_positive_real_sum_reciprocal_abs_zero x hx sqrt_both_sides\n      have result : x = 1 := \n        inequality_positive_real_sum_reciprocal_result x hx abs_zero\n      exact result\n    · -- Backward direction: x = 1 => x + 1/x = 2\n      intro h_eq\n      have substitute : (1 : ℝ) + 1 / 1 = 2 := inequality_positive_real_sum_reciprocal_substitute\n      rw [h_eq]\n      exact substitute"}
