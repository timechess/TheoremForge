{"id": "c28", "nl_problem": "If $x^2 + y = 4$ and $x^4 +y^2 = 10$, then what is $x^2y$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem prove_x2y_value_from_equations : ∀ (x y : ℝ), x^2 + y = 4 → x^4 + y^2 = 10 → x^2 * y = 3 :=", "formal_code": "import Mathlib\ntheorem prove_x2y_value_from_equations : ∀ (x y : ℝ), x^2 + y = 4 → x^4 + y^2 = 10 → x^2 * y = 3 := by\n  intro x y h1 h2\n  -- From h1: x^2 + y = 4, we get y = 4 - x^2\n  have hy : y = 4 - x^2 := by linarith\n  -- Substitute y into h2\n  rw [hy] at h2\n  -- Now h2 is: x^4 + (4 - x^2)^2 = 10\n  -- Expand (4 - x^2)^2 = 16 - 8*x^2 + x^4\n  have expanded : (4 - x^2)^2 = 16 - 8*x^2 + x^4 := by ring\n  rw [expanded] at h2\n  -- h2 is now: x^4 + (16 - 8*x^2 + x^4) = 10\n  -- Simplify to: 2*x^4 - 8*x^2 + 16 = 10\n  have h3 : 2*x^4 - 8*x^2 + 6 = 0 := by linarith\n  -- Divide by 2: x^4 - 4*x^2 + 3 = 0\n  have h4 : x^4 - 4*x^2 + 3 = 0 := by linarith\n  -- Factor as (x^2 - 1)(x^2 - 3) = 0\n  have factored : (x^2 - 1) * (x^2 - 3) = 0 := by nlinarith\n  -- This means x^2 = 1 or x^2 = 3\n  have h5 : x^2 = 1 ∨ x^2 = 3 := by\n    have : x^2 - 1 = 0 ∨ x^2 - 3 = 0 := by\n      rw [mul_eq_zero] at factored\n      exact factored\n    cases this with\n    | inl h => left; linarith\n    | inr h => right; linarith\n  -- In both cases, x^2 * y = 3\n  cases h5 with\n  | inl h_case =>\n    -- Case: x^2 = 1\n    have hy_val : y = 3 := by rw [h_case] at hy; linarith\n    rw [h_case, hy_val]\n    norm_num\n  | inr h_case =>\n    -- Case: x^2 = 3\n    have hy_val : y = 1 := by rw [h_case] at hy; linarith\n    rw [h_case, hy_val]\n    norm_num"}
{"id": "c523", "nl_problem": "Let $a_1, a_2, a_3,\\dots$ be an increasing arithmetic sequence of integers. If $a_4a_5 = 13$, what is $a_3a_6$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem sequence_product_identity (a : PNat → Int) (d : Int) \n  (h_arith : ∀ n : PNat, a (n + 1) = a n + d)\n  (h_d_pos : d > 0)\n  (h_cond : a 4 * a 5 = 13) :\n  a 3 * a 6 = -275 :=", "formal_code": "import Mathlib\ntheorem sequence_product_identity (a : PNat → Int) (d : Int) \n  (h_arith : ∀ n : PNat, a (n + 1) = a n + d)\n  (h_d_pos : d > 0)\n  (h_cond : a 4 * a 5 = 13) :\n  a 3 * a 6 = -275 := by\n  have h_a5 : a 5 = a 4 + d := by\n    have h₁ : a 5 = a 4 + d := by\n      have h₂ := h_arith 4\n      norm_num at h₂ ⊢\n      <;> simpa using h₂\n    exact h₁\n  \n  have h_a4a5 : a 4 * (a 4 + d) = 13 := by\n    have h₁ : a 4 * a 5 = 13 := h_cond\n    rw [h_a5] at h₁\n    <;> ring_nf at h₁ ⊢ <;> linarith\n  \n  have h_a3 : a 3 = a 4 - d := by\n    have h₁ : a 4 = a 3 + d := by\n      have h₂ := h_arith 3\n      norm_num at h₂ ⊢\n      <;> simpa using h₂\n    linarith\n  \n  have h_a6 : a 6 = a 4 + 2 * d := by\n    have h₁ : a 6 = a 5 + d := by\n      have h₂ := h_arith 5\n      norm_num at h₂ ⊢\n      <;> simpa using h₂\n    rw [h₁]\n    have h₂ : a 5 = a 4 + d := h_a5\n    rw [h₂]\n    <;> ring\n    <;> norm_num\n    <;> linarith\n  \n  have h_main : a 3 * a 6 = -275 := by\n    have h₁ : a 4 = 1 ∨ a 4 = -13 := by\n      have h₂ : a 4 * (a 4 + d) = 13 := h_a4a5\n      have h₃ : a 4 = 1 ∨ a 4 = -1 ∨ a 4 = 13 ∨ a 4 = -13 := by\n        have h₄ : a 4 ∣ 13 := by\n          use a 4 + d\n          linarith\n        have h₅ : a 4 = 1 ∨ a 4 = -1 ∨ a 4 = 13 ∨ a 4 = -13 := by\n          rw [← Int.natAbs_dvd_natAbs] at h₄\n          -- We know that the absolute value of `a 4` divides the absolute value of 13, which is 13.\n          have h₆ : (a 4).natAbs ∣ 13 := by\n            simpa [Int.natAbs] using h₄\n          -- The possible divisors of 13 are 1 and 13.\n          have h₇ : (a 4).natAbs = 1 ∨ (a 4).natAbs = 13 := by\n            have h₈ : (a 4).natAbs ∣ 13 := h₆\n            have h₉ : (a 4).natAbs ≤ 13 := Nat.le_of_dvd (by norm_num) h₈\n            interval_cases (a 4).natAbs <;> norm_num at h₈ ⊢ <;> omega\n          -- Convert back to integers.\n          cases h₇ with\n          | inl h₇ =>\n            have h₈ : (a 4).natAbs = 1 := h₇\n            have h₉ : a 4 = 1 ∨ a 4 = -1 := by\n              have h₁₀ : a 4 = 1 ∨ a 4 = -1 := by\n                rw [Int.natAbs_eq_iff] at h₈\n                tauto\n              exact h₁₀\n            cases h₉ with\n            | inl h₉ =>\n              exact Or.inl h₉\n            | inr h₉ =>\n              exact Or.inr (Or.inl h₉)\n          | inr h₇ =>\n            have h₈ : (a 4).natAbs = 13 := h₇\n            have h₉ : a 4 = 13 ∨ a 4 = -13 := by\n              have h₁₀ : a 4 = 13 ∨ a 4 = -13 := by\n                rw [Int.natAbs_eq_iff] at h₈ <;>\n                  (try omega) <;>\n                  (try\n                    {\n                      omega\n                    }) <;>\n                  (try\n                    {\n                      tauto\n                    })\n                <;>\n                  (try\n                    {\n                      omega\n                    })\n              exact h₁₀\n            cases h₉ with\n            | inl h₉ =>\n              exact Or.inr (Or.inr (Or.inl h₉))\n            | inr h₉ =>\n              exact Or.inr (Or.inr (Or.inr h₉))\n        exact h₅\n      -- Now we check each case to see which ones satisfy the condition d > 0.\n      rcases h₃ with (h₃ | h₃ | h₃ | h₃)\n      · -- Case a 4 = 1\n        have h₄ : a 4 = 1 := h₃\n        have h₅ : a 4 * (a 4 + d) = 13 := h_a4a5\n        rw [h₄] at h₅\n        have h₆ : (1 : Int) * (1 + d) = 13 := by simpa using h₅\n        have h₇ : (1 : Int) + d = 13 := by linarith\n        have h₈ : d = 12 := by linarith\n        have h₉ : d > 0 := h_d_pos\n        exact Or.inl h₄\n      · -- Case a 4 = -1\n        have h₄ : a 4 = -1 := h₃\n        have h₅ : a 4 * (a 4 + d) = 13 := h_a4a5\n        rw [h₄] at h₅\n        have h₆ : (-1 : Int) * (-1 + d) = 13 := by simpa using h₅\n        have h₇ : (-1 : Int) + d = -13 := by\n          nlinarith\n        have h₈ : d = -12 := by linarith\n        have h₉ : d > 0 := h_d_pos\n        exfalso\n        linarith\n      · -- Case a 4 = 13\n        have h₄ : a 4 = 13 := h₃\n        have h₅ : a 4 * (a 4 + d) = 13 := h_a4a5\n        rw [h₄] at h₅\n        have h₆ : (13 : Int) * (13 + d) = 13 := by simpa using h₅\n        have h₇ : (13 : Int) + d = 1 := by\n          nlinarith\n        have h₈ : d = -12 := by linarith\n        have h₉ : d > 0 := h_d_pos\n        exfalso\n        linarith\n      · -- Case a 4 = -13\n        have h₄ : a 4 = -13 := h₃\n        have h₅ : a 4 * (a 4 + d) = 13 := h_a4a5\n        rw [h₄] at h₅\n        have h₆ : (-13 : Int) * (-13 + d) = 13 := by simpa using h₅\n        have h₇ : (-13 : Int) + d = -1 := by\n          nlinarith\n        have h₈ : d = 12 := by linarith\n        have h₉ : d > 0 := h_d_pos\n        exact Or.inr h₄\n    -- Now we handle each case separately.\n    rcases h₁ with (h₁ | h₁)\n    · -- Case a 4 = 1\n      have h₂ : a 4 = 1 := h₁\n      have h₃ : a 4 * (a 4 + d) = 13 := h_a4a5\n      rw [h₂] at h₃\n      have h₄ : (1 : Int) * (1 + d) = 13 := by simpa using h₃\n      have h₅ : (1 : Int) + d = 13 := by linarith\n      have h₆ : d = 12 := by linarith\n      have h₇ : a 3 = a 4 - d := h_a3\n      have h₈ : a 6 = a 4 + 2 * d := h_a6\n      rw [h₇, h₈, h₂, h₆]\n      <;> norm_num\n      <;> linarith\n    · -- Case a 4 = -13\n      have h₂ : a 4 = -13 := h₁\n      have h₃ : a 4 * (a 4 + d) = 13 := h_a4a5\n      rw [h₂] at h₃\n      have h₄ : (-13 : Int) * (-13 + d) = 13 := by simpa using h₃\n      have h₅ : (-13 : Int) + d = -1 := by\n        nlinarith\n      have h₆ : d = 12 := by linarith\n      have h₇ : a 3 = a 4 - d := h_a3\n      have h₈ : a 6 = a 4 + 2 * d := h_a6\n      rw [h₇, h₈, h₂, h₆]\n      <;> norm_num\n      <;> linarith\n  \n  exact h_main"}
{"id": "c726", "nl_problem": "Find all values of $x$ that satisfy\n\\[5x - 1 < (x + 1)^2 < 7x - 3.\\]", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem inequality_interval_equivalence : ∀ x : ℝ, (5 * x - 1 < (x + 1)^2 ∧ (x + 1)^2 < 7 * x - 3) ↔ (2 < x ∧ x < 4) :=", "formal_code": "import Mathlib\ntheorem inequality_interval_equivalence : ∀ x : ℝ, (5 * x - 1 < (x + 1)^2 ∧ (x + 1)^2 < 7 * x - 3) ↔ (2 < x ∧ x < 4) := by\n  intro x\n  constructor\n  · intro ⟨h1, h2⟩\n    have eq : (x + 1)^2 = x^2 + 2*x + 1 := by ring\n    rw [eq] at h1 h2\n    have h1' : (x - 1) * (x - 2) > 0 := by nlinarith\n    have h2' : (x - 1) * (x - 4) < 0 := by nlinarith\n    constructor\n    · by_contra h\n      push_neg at h\n      have : x ≤ 2 := h\n      have : (x - 1) * (x - 2) ≤ 0 := by nlinarith\n      linarith\n    · by_contra h\n      push_neg at h\n      have : x ≥ 4 := h\n      have : (x - 1) * (x - 4) ≥ 0 := by nlinarith\n      linarith\n  · intro ⟨h1, h2⟩\n    constructor\n    · have eq : (x + 1)^2 = x^2 + 2*x + 1 := by ring\n      rw [eq]\n      nlinarith\n    · have eq : (x + 1)^2 = x^2 + 2*x + 1 := by ring\n      rw [eq]\n      nlinarith"}
{"id": "c667", "nl_problem": "Suppose that $a$ and $b$ are positive integers such that $(a+bi)^2 = 3+4i$. What is $a+bi$?", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem gaussian_integer_square_root (a b : ℕ) (ha : 0 < a) (hb : 0 < b) \n  (h : (↑a + ↑b * Complex.I) ^ 2 = 3 + 4 * Complex.I) : \n  ↑a + ↑b * Complex.I = 2 + Complex.I :=", "formal_code": "import Mathlib\ntheorem gaussian_integer_square_root (a b : ℕ) (ha : 0 < a) (hb : 0 < b) \n  (h : (↑a + ↑b * Complex.I) ^ 2 = 3 + 4 * Complex.I) : \n  ↑a + ↑b * Complex.I = 2 + Complex.I := by\n  have h₁ : (a : ℝ) ^ 2 - (b : ℝ) ^ 2 = 3 := by\n    have h₁₁ := h\n    simp [Complex.ext_iff, pow_two, Complex.ext_iff, Complex.I_mul_I, Complex.I_mul_I,\n      Complex.I_mul_I, Complex.I_mul_I] at h₁₁ ⊢\n    norm_num at h₁₁ ⊢\n    <;>\n    (try ring_nf at h₁₁ ⊢) <;>\n    (try norm_num at h₁₁ ⊢) <;>\n    (try nlinarith) <;>\n    (try linarith) <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      }) <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n  \n  have h₂ : 2 * (a : ℝ) * (b : ℝ) = 4 := by\n    have h₂₁ := h\n    simp [Complex.ext_iff, pow_two, Complex.ext_iff, Complex.I_mul_I, Complex.I_mul_I,\n      Complex.I_mul_I, Complex.I_mul_I] at h₂₁ ⊢\n    norm_num at h₂₁ ⊢\n    <;>\n    (try ring_nf at h₂₁ ⊢) <;>\n    (try norm_num at h₂₁ ⊢) <;>\n    (try nlinarith) <;>\n    (try linarith) <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      }) <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg ((a : ℝ) - (b : ℝ)), sq_nonneg ((a : ℝ) + (b : ℝ))]\n      })\n  \n  have h₃ : a * b = 2 := by\n    have h₃₁ : (a : ℝ) * (b : ℝ) = 2 := by\n      have h₃₂ : 2 * (a : ℝ) * (b : ℝ) = 4 := h₂\n      have h₃₃ : (a : ℝ) * (b : ℝ) = 2 := by\n        linarith\n      exact h₃₃\n    have h₃₄ : (a : ℕ) * (b : ℕ) = 2 := by\n      norm_cast at h₃₁ ⊢\n      <;>\n      (try norm_num at h₃₁ ⊢) <;>\n      (try ring_nf at h₃₁ ⊢) <;>\n      (try field_simp at h₃₁ ⊢) <;>\n      (try norm_cast at h₃₁ ⊢) <;>\n      (try nlinarith) <;>\n      (try linarith)\n      <;>\n      (try\n        {\n          simp_all [mul_comm, mul_assoc, mul_left_comm]\n          <;>\n          nlinarith\n        })\n    exact h₃₄\n  \n  have h₄ : a = 2 ∧ b = 1 := by\n    have h₄₁ : a * b = 2 := h₃\n    have h₄₂ : 0 < a := ha\n    have h₄₃ : 0 < b := hb\n    have h₄₄ : a = 1 ∨ a = 2 := by\n      have h₄₅ : a ∣ 2 := by\n        use b\n        linarith\n      have h₄₆ : a ≤ 2 := by\n        have h₄₇ : a ∣ 2 := h₄₅\n        have h₄₈ : a ≤ 2 := Nat.le_of_dvd (by norm_num) h₄₇\n        exact h₄₈\n      interval_cases a <;> norm_num at h₄₅ ⊢ <;>\n        (try omega) <;>\n        (try\n          {\n            have h₄₉ : b = 2 := by\n              nlinarith\n            simp_all\n          }) <;>\n        (try\n          {\n            have h₄₉ : b = 1 := by\n              nlinarith\n            simp_all\n          })\n    cases h₄₄ with\n    | inl h₄₄ =>\n      have h₄₅ : a = 1 := h₄₄\n      have h₄₆ : b = 2 := by\n        have h₄₇ : a * b = 2 := h₃\n        rw [h₄₅] at h₄₇\n        norm_num at h₄₇ ⊢\n        <;> nlinarith\n      have h₄₈ : (a : ℝ) ^ 2 - (b : ℝ) ^ 2 = 3 := h₁\n      rw [h₄₅, h₄₆] at h₄₈\n      norm_num at h₄₈\n      <;>\n      (try contradiction) <;>\n      (try\n        {\n          exfalso\n          linarith\n        })\n      <;>\n      (try\n        {\n          simp_all\n          <;>\n          norm_num at *\n          <;>\n          linarith\n        })\n    | inr h₄₄ =>\n      have h₄₅ : a = 2 := h₄₄\n      have h₄₆ : b = 1 := by\n        have h₄₇ : a * b = 2 := h₃\n        rw [h₄₅] at h₄₇\n        norm_num at h₄₇ ⊢\n        <;> nlinarith\n      exact ⟨h₄₅, h₄₆⟩\n  \n  have h₅ : ↑a + ↑b * Complex.I = 2 + Complex.I := by\n    have h₅₁ : a = 2 := h₄.1\n    have h₅₂ : b = 1 := h₄.2\n    rw [h₅₁, h₅₂]\n    <;> simp [Complex.ext_iff, pow_two, Complex.ext_iff, Complex.I_mul_I, Complex.I_mul_I]\n    <;> norm_num\n    <;>\n    (try ring_nf) <;>\n    (try norm_num) <;>\n    (try linarith)\n  \n  exact h₅"}
{"id": "c409", "nl_problem": "Find the value of $a$ so that the lines described by\n\\[\\begin{pmatrix} 2 \\\\ -1 \\\\ 0 \\end{pmatrix} + t \\begin{pmatrix} a \\\\ -2 \\\\ 1 \\end{pmatrix}\\]and\n\\[\\begin{pmatrix} 1 \\\\ -3/2 \\\\ -5 \\end{pmatrix} + u \\begin{pmatrix} 1 \\\\ 3/2 \\\\ 2 \\end{pmatrix}\\]are perpendicular.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem line_perpendicularity_condition (a : ℝ) : \n  let d1 : Fin 3 → ℝ := ![a, -2, 1]\n  let d2 : Fin 3 → ℝ := ![1, 3/2, 2]\n  (Matrix.dotProduct d1 d2 = 0) → a = 1 :=", "formal_code": "import Mathlib\ntheorem line_perpendicularity_condition (a : ℝ) : \n  let d1 : Fin 3 → ℝ := ![a, -2, 1]\n  let d2 : Fin 3 → ℝ := ![1, 3/2, 2]\n  (Matrix.dotProduct d1 d2 = 0) → a = 1 := by\n  intro d1 d2 h\n  have h₁ : Matrix.dotProduct d1 d2 = a - 1 := by\n    simp [d1, d2, Matrix.dotProduct, Fin.sum_univ_succ, Fin.val_zero, Fin.val_succ]\n    <;> norm_num <;> ring_nf <;> norm_num <;> linarith\n  \n  have h₂ : a - 1 = 0 := by\n    linarith\n  \n  have h₃ : a = 1 := by\n    linarith\n  \n  exact h₃"}
{"id": "c4014", "nl_problem": "Let $S$ be any ring and let $n>2$ be an integer.\n    Prove that if \\( A \\) is any strictly upper triangular matrix in \\( M_n(S) \\), then \\( A^n = 0 \\). (A strictly upper triangular matrix is one whose entries on and below the main diagonal are all zero.)", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem strictly_upper_triangular_power_zero (S : Type*) [Ring S] (n : ℕ) (hn : n > 2) \n  (A : Matrix (Fin n) (Fin n) S) \n  (h_strict : ∀ i j : Fin n, i ≥ j → A i j = 0) : \n  A ^ n = 0 :=", "formal_code": "import Mathlib\ntheorem strictly_upper_triangular_power_zero (S : Type*) [Ring S] (n : ℕ) (hn : n > 2) \n  (A : Matrix (Fin n) (Fin n) S) \n  (h_strict : ∀ i j : Fin n, i ≥ j → A i j = 0) : \n  A ^ n = 0 := by\n  have h_main : ∀ (k : ℕ) (i j : Fin n), j.val < i.val + k → (A ^ k) i j = 0 := by\n    intro k\n    induction' k with k ih\n    · -- Base case: k = 0\n      intro i j h\n      have h₁ : j.val < i.val + 0 := h\n      have h₂ : j.val < i.val := by simpa using h₁\n      have h₃ : (A ^ 0 : Matrix (Fin n) (Fin n) S) i j = if i = j then 1 else 0 := by\n        simp [Matrix.one_apply]\n      rw [h₃]\n      split_ifs with h₄\n      · -- Case i = j\n        exfalso\n        have h₅ : i.val = j.val := by\n          simp_all [Fin.ext_iff]\n        omega\n      · -- Case i ≠ j\n        simp\n    · -- Inductive step: assume the statement holds for k, prove for k + 1\n      intro i j h\n      have h₁ : j.val < i.val + (k + 1) := h\n      have h₂ : (A ^ (k + 1)) i j = ∑ m : Fin n, (A ^ k) i m * A m j := by\n        simp [pow_succ, Matrix.mul_apply]\n      rw [h₂]\n      have h₃ : ∑ m : Fin n, (A ^ k) i m * A m j = 0 := by\n        apply Finset.sum_eq_zero\n        intro m _\n        by_cases h₄ : m.val < i.val + k\n        · -- Case: m.val < i.val + k\n          have h₅ : (A ^ k) i m = 0 := ih i m h₄\n          rw [h₅]\n          simp\n        · -- Case: m.val ≥ i.val + k\n          have h₅ : m.val ≥ i.val + k := by\n            omega\n          have h₆ : m.val ≥ j.val := by\n            have h₇ : j.val < i.val + (k + 1) := h₁\n            have h₈ : j.val ≤ i.val + k := by\n              omega\n            omega\n          have h₇ : (m : Fin n) ≥ (j : Fin n) := by\n            exact Fin.le_def.mpr h₆\n          have h₈ : A m j = 0 := h_strict m j h₇\n          rw [h₈]\n          simp\n      rw [h₃]\n  \n  have h_final : A ^ n = 0 := by\n    apply Matrix.ext\n    intro i j\n    have h₁ : j.val < i.val + n := by\n      have h₂ : j.val < n := j.is_lt\n      have h₃ : i.val ≥ 0 := by\n        exact Nat.zero_le _\n      omega\n    have h₂ : (A ^ n) i j = 0 := h_main n i j h₁\n    simp [h₂]\n  \n  exact h_final"}
{"id": "c198", "nl_problem": "Let $p(x)$ be a monic polynomial of degree 4.  Three of the roots of $p(x)$ are 1, 2, and 3.  Find $p(0) + p(4).$", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem polynomial_root_sum_identity (r : ℝ) (p : Polynomial ℝ) \n  (h_monic : p.Monic)\n  (h_degree : p.natDegree = 4)\n  (h_factored : p = (Polynomial.X - Polynomial.C 1) * (Polynomial.X - Polynomial.C 2) * (Polynomial.X - Polynomial.C 3) * (Polynomial.X - Polynomial.C r)) :\n  p.eval 0 + p.eval 4 = 24 :=", "formal_code": "import Mathlib\ntheorem polynomial_root_sum_identity (r : ℝ) (p : Polynomial ℝ) \n  (h_monic : p.Monic)\n  (h_degree : p.natDegree = 4)\n  (h_factored : p = (Polynomial.X - Polynomial.C 1) * (Polynomial.X - Polynomial.C 2) * (Polynomial.X - Polynomial.C 3) * (Polynomial.X - Polynomial.C r)) :\n  p.eval 0 + p.eval 4 = 24 := by\n  rw [h_factored]\n  simp only [Polynomial.eval_mul, Polynomial.eval_sub, Polynomial.eval_X, Polynomial.eval_C]\n  ring"}
{"id": "c499", "nl_problem": "The lengths of the sides of a triangle are consecutive integers, and the largest angle is twice the smallest angle.  Find the cosine of the smallest angle.", "formal_type": "Lean", "header": "import Mathlib\n", "formal_statement": "theorem triangle_angle_cosine_identity (n : ℤ) (hn : n > 2) \n  (α γ : ℝ)\n  (h_alpha_cos : Real.cos α = ((n + 1 : ℝ)^2 + (n + 2 : ℝ)^2 - (n : ℝ)^2) / (2 * (n + 1 : ℝ) * (n + 2 : ℝ)))\n  (h_gamma_cos : Real.cos γ = ((n : ℝ)^2 + (n + 1 : ℝ)^2 - (n + 2 : ℝ)^2) / (2 * (n : ℝ) * (n + 1 : ℝ)))\n  (h_relation : γ = 2 * α) :\n  Real.cos α = 3/4 :=", "formal_code": "import Mathlib\ntheorem triangle_angle_cosine_identity (n : ℤ) (hn : n > 2) \n  (α γ : ℝ)\n  (h_alpha_cos : Real.cos α = ((n + 1 : ℝ)^2 + (n + 2 : ℝ)^2 - (n : ℝ)^2) / (2 * (n + 1 : ℝ) * (n + 2 : ℝ)))\n  (h_gamma_cos : Real.cos γ = ((n : ℝ)^2 + (n + 1 : ℝ)^2 - (n + 2 : ℝ)^2) / (2 * (n : ℝ) * (n + 1 : ℝ)))\n  (h_relation : γ = 2 * α) :\n  Real.cos α = 3/4 := by\n  have h_n_pos : (n : ℝ) > 2 := by\n    exact_mod_cast hn\n  \n  have h_n1_pos : (n + 1 : ℝ) > 0 := by\n    have h₁ : (n : ℝ) > 2 := h_n_pos\n    have h₂ : (n : ℝ) + 1 > 0 := by linarith\n    exact_mod_cast h₂\n  \n  have h_n2_pos : (n + 2 : ℝ) > 0 := by\n    have h₁ : (n : ℝ) > 2 := h_n_pos\n    have h₂ : (n : ℝ) + 2 > 0 := by linarith\n    exact_mod_cast h₂\n  \n  have h_cosα_simplified : Real.cos α = ((n : ℝ) + 5) / (2 * ((n : ℝ) + 2)) := by\n    have h₁ : Real.cos α = ((n + 1 : ℝ)^2 + (n + 2 : ℝ)^2 - (n : ℝ)^2) / (2 * (n + 1 : ℝ) * (n + 2 : ℝ)) := h_alpha_cos\n    have h₂ : ((n + 1 : ℝ)^2 + (n + 2 : ℝ)^2 - (n : ℝ)^2) = (n : ℝ)^2 + 6 * (n : ℝ) + 5 := by\n      ring_nf\n      <;> norm_cast\n      <;> ring_nf at hn ⊢\n      <;> nlinarith\n    have h₃ : (2 * (n + 1 : ℝ) * (n + 2 : ℝ)) = 2 * ((n : ℝ) + 1) * ((n : ℝ) + 2) := by\n      ring_nf\n      <;> norm_cast\n    rw [h₁, h₂, h₃]\n    have h₄ : (n : ℝ) + 1 ≠ 0 := by linarith\n    have h₅ : (n : ℝ) + 2 ≠ 0 := by linarith\n    have h₆ : (n : ℝ)^2 + 6 * (n : ℝ) + 5 = ((n : ℝ) + 1) * ((n : ℝ) + 5) := by\n      ring_nf\n      <;> norm_cast\n      <;> ring_nf at hn ⊢\n      <;> nlinarith\n    rw [h₆]\n    field_simp [h₄, h₅]\n    <;> ring_nf\n    <;> field_simp [h₄, h₅]\n    <;> ring_nf\n    <;> norm_cast\n    <;> field_simp [h₄, h₅]\n    <;> ring_nf\n    <;> norm_cast\n    <;> linarith\n  \n  have h_cosγ_simplified : Real.cos γ = ((n : ℝ) - 3) / (2 * (n : ℝ)) := by\n    have h₁ : Real.cos γ = ((n : ℝ)^2 + (n + 1 : ℝ)^2 - (n + 2 : ℝ)^2) / (2 * (n : ℝ) * (n + 1 : ℝ)) := h_gamma_cos\n    have h₂ : ((n : ℝ)^2 + (n + 1 : ℝ)^2 - (n + 2 : ℝ)^2) = (n : ℝ)^2 - 2 * (n : ℝ) - 3 := by\n      ring_nf\n      <;> norm_cast\n      <;> ring_nf at hn ⊢\n      <;> nlinarith\n    have h₃ : (2 * (n : ℝ) * (n + 1 : ℝ)) = 2 * (n : ℝ) * ((n : ℝ) + 1) := by\n      ring_nf\n      <;> norm_cast\n    rw [h₁, h₂, h₃]\n    have h₄ : (n : ℝ) ≠ 0 := by\n      have h₅ : (n : ℝ) > 2 := h_n_pos\n      linarith\n    have h₅ : (n : ℝ) + 1 ≠ 0 := by\n      have h₆ : (n : ℝ) > 2 := h_n_pos\n      linarith\n    have h₆ : (n : ℝ)^2 - 2 * (n : ℝ) - 3 = ((n : ℝ) - 3) * ((n : ℝ) + 1) := by\n      ring_nf\n      <;> norm_cast\n      <;> ring_nf at hn ⊢\n      <;> nlinarith\n    rw [h₆]\n    field_simp [h₄, h₅]\n    <;> ring_nf\n    <;> field_simp [h₄, h₅]\n    <;> ring_nf\n    <;> norm_cast\n    <;> field_simp [h₄, h₅]\n    <;> ring_nf\n    <;> norm_cast\n    <;> linarith\n  \n  have h_cosγ_double_angle : Real.cos γ = 2 * (Real.cos α)^2 - 1 := by\n    have h₁ : γ = 2 * α := h_relation\n    have h₂ : Real.cos γ = Real.cos (2 * α) := by rw [h₁]\n    rw [h₂]\n    have h₃ : Real.cos (2 * α) = 2 * (Real.cos α)^2 - 1 := by\n      rw [Real.cos_two_mul]\n      <;> ring_nf\n      <;> simp [Real.cos_sq]\n      <;> ring_nf\n    rw [h₃]\n    <;> ring_nf\n  \n  have h_cubic_equation : 2 * (n : ℝ)^3 - (n : ℝ)^2 - 25 * (n : ℝ) - 12 = 0 := by\n    have h₁ : Real.cos γ = ((n : ℝ) - 3) / (2 * (n : ℝ)) := h_cosγ_simplified\n    have h₂ : Real.cos γ = 2 * (Real.cos α)^2 - 1 := h_cosγ_double_angle\n    have h₃ : Real.cos α = ((n : ℝ) + 5) / (2 * ((n : ℝ) + 2)) := h_cosα_simplified\n    have h₄ : ((n : ℝ) - 3) / (2 * (n : ℝ)) = 2 * (Real.cos α)^2 - 1 := by linarith\n    rw [h₃] at h₄\n    have h₅ : ((n : ℝ) - 3) / (2 * (n : ℝ)) = 2 * (((n : ℝ) + 5) / (2 * ((n : ℝ) + 2)))^2 - 1 := by\n      linarith\n    have h₆ : (n : ℝ) ≠ 0 := by\n      have h₇ : (n : ℝ) > 2 := h_n_pos\n      linarith\n    have h₇ : (n : ℝ) + 2 ≠ 0 := by\n      have h₈ : (n : ℝ) > 2 := h_n_pos\n      linarith\n    field_simp at h₅\n    ring_nf at h₅ ⊢\n    nlinarith [sq_pos_of_pos (sub_pos.mpr h_n_pos), sq_pos_of_pos h_n1_pos, sq_pos_of_pos h_n2_pos]\n  \n  have h_n_eq_4 : n = 4 := by\n    have h₁ : (n : ℝ) > 2 := h_n_pos\n    have h₂ : 2 * (n : ℝ)^3 - (n : ℝ)^2 - 25 * (n : ℝ) - 12 = 0 := h_cubic_equation\n    have h₃ : n ≤ 4 := by\n      by_contra! h\n      have h₄ : n ≥ 5 := by linarith\n      have h₅ : (n : ℝ) ≥ 5 := by exact_mod_cast h₄\n      have h₆ : 2 * (n : ℝ)^3 - (n : ℝ)^2 - 25 * (n : ℝ) - 12 > 0 := by\n        nlinarith [sq_nonneg ((n : ℝ) - 4), sq_nonneg ((n : ℝ) - 5)]\n      linarith\n    have h₄ : n ≥ 3 := by\n      by_contra! h\n      have h₅ : n ≤ 2 := by linarith\n      have h₆ : (n : ℝ) ≤ 2 := by exact_mod_cast h₅\n      have h₇ : (n : ℝ) > 2 := h_n_pos\n      linarith\n    interval_cases n <;> norm_num at h₂ ⊢ <;>\n      (try { contradiction }) <;>\n      (try { linarith }) <;>\n      (try { nlinarith })\n  \n  have h_final : Real.cos α = 3/4 := by\n    have h₁ : Real.cos α = ((n : ℝ) + 5) / (2 * ((n : ℝ) + 2)) := h_cosα_simplified\n    rw [h₁]\n    have h₂ : (n : ℝ) = 4 := by\n      norm_cast\n      <;> simp [h_n_eq_4]\n    rw [h₂]\n    <;> norm_num\n    <;> field_simp\n    <;> ring_nf\n    <;> norm_num\n  \n  exact h_final"}
